{"version":3,"file":"iterator.js","sourceRoot":"","sources":["iterator.ts"],"names":[],"mappings":";;;;;;;;;;;IAmBA;;;OAGG;IACH,oBAA2B,KAAU;QACpC,MAAM,CAAC,KAAK,IAAI,OAAO,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,WAAW,CAAC;IAC/D,CAAC;IAFD,gCAEC;IAED;;;OAGG;IACH,qBAA4B,KAAU;QACrC,MAAM,CAAC,KAAK,IAAI,OAAO,KAAK,CAAC,MAAM,KAAK,WAAW,CAAC;IACrD,CAAC;IAFD,kCAEC;IAED;;;;OAIG;IACH,aAAuB,QAA6C;QACnE,EAAE,CAAC,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;YAC1B,oEAAoE;YACpE,MAAM,CAAQ,QAAS,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC;QAC5C,CAAC;IACF,CAAC;IALD,kBAKC;IAAA,CAAC;IAaF;;;;;;OAMG;IACH,eAAyB,QAA6C,EAAE,QAA0B,EAAE,OAAa;QAChH,IAAI,MAAM,GAAG,KAAK,CAAC;QAEnB;YACC,MAAM,GAAG,IAAI,CAAC;QACf,CAAC;QAED,IAAM,QAAQ,GAAG,GAAG,CAAC,QAAQ,CAAC,CAAC;QAC/B,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;YACf,MAAM,IAAI,SAAS,CAAC,oCAAoC,CAAC,CAAC;QAC3D,CAAC;QACD,IAAI,MAAM,GAAG,QAAQ,CAAC,IAAI,EAAE,CAAC;QAE7B;;;;;WAKG;QACH,OAAO,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC;YACrB,QAAQ,CAAC,IAAI,CAAC,OAAO,EAAE,MAAM,CAAC,KAAK,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;YACxD,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;gBACZ,MAAM,CAAC;YACR,CAAC;YACD,MAAM,GAAG,QAAQ,CAAC,IAAI,EAAE,CAAC;QAC1B,CAAC;IACF,CAAC;IA1BD,sBA0BC","sourcesContent":["export interface IteratorResult<T> {\n\treadonly done: boolean;\n\treadonly value?: T;\n}\n\nexport interface Iterator<T> {\n\tnext(value?: any): IteratorResult<T>;\n\treturn?(value?: any): IteratorResult<T>;\n\tthrow?(e?: any): IteratorResult<T>;\n}\n\nexport interface Iterable<T> {\n\t[Symbol.iterator](): Iterator<T>;\n}\n\nexport interface IterableIterator<T> extends Iterator<T> {\n\t[Symbol.iterator](): IterableIterator<T>;\n}\n\n/**\n * A type guard for checking if something has an Iterable interface\n * @param value The value to type guard against\n */\nexport function isIterable(value: any): value is Iterable<any> {\n\treturn value && typeof value[Symbol.iterator] !== 'undefined';\n}\n\n/**\n * A type guard for checking if something is ArrayLike\n * @param value The value to type guard against\n */\nexport function isArrayLike(value: any): value is ArrayLike<any> {\n\treturn value && typeof value.length !== 'undefined';\n}\n\n/**\n * Returns the iterator for an object\n *\n * @param iterable The iterable object to return the iterator for\n */\nexport function get<T>(iterable: Iterable<T> | ArrayLike<T> | string): Iterator<T> | undefined {\n\tif (isIterable(iterable)) {\n\t\t/* have to cast as any, because the assumed index is implicit any */\n\t\treturn (<any> iterable)[Symbol.iterator]();\n\t}\n};\n\nexport interface ForOfCallback<T> {\n\t/**\n\t * A callback function for a forOf() iteration\n\t *\n\t * @param value The current value\n\t * @param object The object being iterated over\n\t * @param doBreak A function, if called, will stop the iteration\n\t */\n\t(value: T, object: Iterable<T> | ArrayLike<T> | string, doBreak: () => void): void;\n}\n\n/**\n * Shims the functionality of `for ... of` blocks\n *\n * @param iterable The object the provides an interator interface\n * @param callback The callback which will be called for each item of the iterable\n * @param thisArg Optional scope to pass the callback\n */\nexport function forOf<T>(iterable: Iterable<T> | ArrayLike<T> | string, callback: ForOfCallback<T>, thisArg?: any): void {\n\tlet broken = false;\n\n\tfunction doBreak() {\n\t\tbroken = true;\n\t}\n\n\tconst iterator = get(iterable);\n\tif (!iterator) {\n\t\tthrow new TypeError('Cannot resolve iterator interface.');\n\t}\n\tlet result = iterator.next();\n\n\t/**\n\t * TypeScript when targetting ES5 will destructure `foo ... of` only for array like objects\n\t * using a `for` loop.  This obviously causes problems when trying to support iterator\n\t * functionality and would not make the code transparent between ES5 and ES6, therefore\n\t * creating our own iterator loop that would work seemlessly, irrespective of the target\n\t */\n\twhile (!result.done) {\n\t\tcallback.call(thisArg, result.value, iterable, doBreak);\n\t\tif (broken) {\n\t\t\treturn;\n\t\t}\n\t\tresult = iterator.next();\n\t}\n}\n"]}