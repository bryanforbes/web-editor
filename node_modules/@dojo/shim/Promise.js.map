{"version":3,"file":"Promise.js","sourceRoot":"","sources":["Promise.ts"],"names":[],"mappings":"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","sourcesContent":["import { Thenable } from './interfaces';\nimport global from './support/global';\nimport { queueMicroTask } from './support/queue';\nimport { forOf, Iterable } from './iterator';\nimport './Symbol';\nimport { hasClass } from './support/decorators';\nimport has from './support/has';\n\n/**\n * Executor is the interface for functions used to initialize a Promise.\n */\nexport interface Executor<T> {\n\t/**\n\t * The executor for the promise\n\t *\n\t * @param resolve The resolver callback of the promise\n\t * @param reject The rejector callback of the promise\n\t */\n\t(resolve: (value?: T | Thenable<T>) => void, reject: (reason?: any) => void): void;\n}\n\nmodule Shim {\n\n\t/**\n\t * The State enum represents the possible states of a promise.\n\t */\n\texport const enum State {\n\t\tFulfilled,\n\t\tPending,\n\t\tRejected\n\t}\n\n\t/**\n\t * Returns true if a given value has a `then` method.\n\t * @param {any} value The value to check if is Thenable\n\t * @returns {is Thenable<T>} A type guard if the value is thenable\n\t */\n\texport function isThenable<T>(value: any): value is Thenable<T> {\n\t\treturn value && typeof value.then === 'function';\n\t}\n\n\t/**\n\t * Promise is a partial implementation of the ES2015 Promise specification. It relies on Promise to do some safety\n\t * checks such as verifying that a Promise isn't resolved with itself. This class is exported for testability, and is\n\t * not intended to be used directly.\n\t *\n\t * @borrows Promise.all as Promise.all\n\t * @borrows Promise.race as Promise.race\n\t * @borrows Promise.reject as Promise.reject\n\t * @borrows Promise.resolve as Promise.resolve\n\t * @borrows Promise#catch as Promise#catch\n\t * @borrows Promise#then as Promise#then\n\t */\n\texport class Promise<T> implements Thenable<T> {\n\t\tstatic all<T>(iterable: Iterable<(T | Thenable<T>)> | (T | Thenable<T>)[]): Promise<T[]> {\n\t\t\treturn new this(function (resolve, reject) {\n\t\t\t\tconst values: T[] = [];\n\t\t\t\tlet complete = 0;\n\t\t\t\tlet total = 0;\n\t\t\t\tlet populating = true;\n\n\t\t\t\tfunction fulfill(index: number, value: any): void {\n\t\t\t\t\tvalues[ index ] = value;\n\t\t\t\t\t++complete;\n\t\t\t\t\tfinish();\n\t\t\t\t}\n\n\t\t\t\tfunction finish(): void {\n\t\t\t\t\tif (populating || complete < total) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tresolve(values);\n\t\t\t\t}\n\n\t\t\t\tfunction processItem(index: number, item: (T | Thenable<T>)): void {\n\t\t\t\t\t++total;\n\t\t\t\t\tif (isThenable(item)) {\n\t\t\t\t\t\t// If an item Promise rejects, this Promise is immediately rejected with the item\n\t\t\t\t\t\t// Promise's rejection error.\n\t\t\t\t\t\titem.then(fulfill.bind(null, index), reject);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPromise.resolve(item).then(fulfill.bind(null, index));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet i = 0;\n\t\t\t\tforOf(iterable, function (value: T | Thenable<T>) {\n\t\t\t\t\tprocessItem(i, value);\n\t\t\t\t\ti++;\n\t\t\t\t});\n\t\t\t\tpopulating = false;\n\n\t\t\t\tfinish();\n\t\t\t});\n\t\t}\n\n\t\tstatic race<T>(iterable: Iterable<(T | Thenable<T>)> | (T | Thenable<T>)[]): Promise<T[]> {\n\t\t\treturn new this(function (resolve, reject) {\n\t\t\t\tforOf(iterable, function (item: T | Thenable<T>) {\n\t\t\t\t\tif (item instanceof Promise) {\n\t\t\t\t\t\t// If a Promise item rejects, this Promise is immediately rejected with the item\n\t\t\t\t\t\t// Promise's rejection error.\n\t\t\t\t\t\titem.then(resolve, reject);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tPromise.resolve(item).then(resolve);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\tstatic reject<T>(reason?: any): Promise<T> {\n\t\t\treturn new this(function (resolve, reject) {\n\t\t\t\treject(reason);\n\t\t\t});\n\t\t}\n\n\t\tstatic resolve(): Promise<void>;\n\t\tstatic resolve<T>(value: (T | Thenable<T>)): Promise<T>;\n\t\tstatic resolve<T>(value?: any): Promise<T> {\n\t\t\treturn new this(function (resolve) {\n\t\t\t\tresolve(<T> value);\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Creates a new Promise.\n\t\t *\n\t\t * @constructor\n\t\t *\n\t\t * @param executor\n\t\t * The executor function is called immediately when the Promise is instantiated. It is responsible for\n\t\t * starting the asynchronous operation when it is invoked.\n\t\t *\n\t\t * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n\t\t * successfully, or the `reject` function when the operation fails.\n\t\t */\n\t\tconstructor(executor: Executor<T>) {\n\t\t\t/**\n\t\t\t * If true, the resolution of this promise is chained (\"locked in\") to another promise.\n\t\t\t */\n\t\t\tlet isChained = false;\n\n\t\t\t/**\n\t\t\t * Whether or not this promise is in a resolved state.\n\t\t\t */\n\t\t\tconst isResolved = (): boolean => {\n\t\t\t\treturn this.state !== State.Pending || isChained;\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Callbacks that should be invoked once the asynchronous operation has completed.\n\t\t\t */\n\t\t\tlet callbacks: null | (Array<() => void>) = [];\n\n\t\t\t/**\n\t\t\t * Initially pushes callbacks onto a queue for execution once this promise settles. After the promise settles,\n\t\t\t * enqueues callbacks for execution on the next event loop turn.\n\t\t\t */\n\t\t\tlet whenFinished = function (callback: () => void): void {\n\t\t\t\tif (callbacks) {\n\t\t\t\t\tcallbacks.push(callback);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Settles this promise.\n\t\t\t *\n\t\t\t * @param newState The resolved state for this promise.\n\t\t\t * @param {T|any} value The resolved value for this promise.\n\t\t\t */\n\t\t\tconst settle = (newState: State, value: any): void => {\n\t\t\t\t// A promise can only be settled once.\n\t\t\t\tif (this.state !== State.Pending) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.state = newState;\n\t\t\t\tthis.resolvedValue = value;\n\t\t\t\twhenFinished = queueMicroTask;\n\n\t\t\t\t// Only enqueue a callback runner if there are callbacks so that initially fulfilled Promises don't have to\n\t\t\t\t// wait an extra turn.\n\t\t\t\tif (callbacks && callbacks.length > 0) {\n\t\t\t\t\tqueueMicroTask(function (): void {\n\t\t\t\t\t\tif (callbacks) {\n\t\t\t\t\t\t\tlet count = callbacks.length;\n\t\t\t\t\t\t\tfor (let i = 0; i < count; ++i) {\n\t\t\t\t\t\t\t\tcallbacks[ i ].call(null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcallbacks = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Resolves this promise.\n\t\t\t *\n\t\t\t * @param newState The resolved state for this promise.\n\t\t\t * @param {T|any} value The resolved value for this promise.\n\t\t\t */\n\t\t\tconst resolve = (newState: State, value: any): void => {\n\t\t\t\tif (isResolved()) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (isThenable(value)) {\n\t\t\t\t\tvalue.then(\n\t\t\t\t\t\tsettle.bind(null, State.Fulfilled),\n\t\t\t\t\t\tsettle.bind(null, State.Rejected)\n\t\t\t\t\t);\n\t\t\t\t\tisChained = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsettle(newState, value);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.then = <U>(onFulfilled?: (value?: T) => (U | Promise<U>),\n\t\t\t\t\t\t\tonRejected?: (reason?: any) => (U | Promise<U>)): Promise<U> => {\n\t\t\t\treturn new Promise<U>((resolve, reject) => {\n\t\t\t\t\t// whenFinished initially queues up callbacks for execution after the promise has settled. Once the\n\t\t\t\t\t// promise has settled, whenFinished will schedule callbacks for execution on the next turn through the\n\t\t\t\t\t// event loop.\n\t\t\t\t\twhenFinished(() => {\n\t\t\t\t\t\tconst callback: ((value?: any) => any) | undefined = this.state === State.Rejected ? onRejected : onFulfilled;\n\n\t\t\t\t\t\tif (typeof callback === 'function') {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tresolve(callback(this.resolvedValue));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (error) {\n\t\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (this.state === State.Rejected) {\n\t\t\t\t\t\t\treject(this.resolvedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tresolve(this.resolvedValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t};\n\n\t\t\ttry {\n\t\t\t\t(<Executor<T>> executor)(\n\t\t\t\t\tresolve.bind(null, State.Fulfilled),\n\t\t\t\t\tresolve.bind(null, State.Rejected)\n\t\t\t\t);\n\t\t\t}\n\t\t\tcatch (error) {\n\t\t\t\tsettle(State.Rejected, error);\n\t\t\t}\n\t\t}\n\n\t\tcatch<U>(onRejected: (reason: any) => (U | Thenable<U>)): Promise<U> {\n\t\t\treturn this.then<U>(undefined, onRejected);\n\t\t}\n\n\t\t/**\n\t\t * The current state of this promise.\n\t\t */\n\t\tprivate state = State.Pending;\n\n\t\t/**\n\t\t * The resolved value for this promise.\n\t\t *\n\t\t * @type {T|any}\n\t\t */\n\t\tprivate resolvedValue: any;\n\n\t\tthen: <U>(onFulfilled?: (value: T) => (U | Thenable<U>), onRejected?: (reason: any) => (U | Thenable<U>)) => Promise<U>;\n\n\t\t[Symbol.toStringTag] = 'Promise';\n\t}\n}\n\n@hasClass('es6-promise', global.Promise, Shim.Promise)\nexport default class Promise<T> implements Thenable<T> {\n\t/**\n\t * Creates a new Promise.\n\t *\n\t * @constructor\n\t *\n\t * @param executor\n\t * The executor function is called immediately when the Promise is instantiated. It is responsible for\n\t * starting the asynchronous operation when it is invoked.\n\t *\n\t * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n\t * successfully, or the `reject` function when the operation fails.\n\t */\n\t/* istanbul ignore next */\n\tconstructor(executor: Executor<T>) {\n\t}\n\n\t/**\n\t * Converts an iterable object containing promises into a single promise that resolves to a new iterable object\n\t * containing the fulfilled values of all the promises in the iterable, in the same order as the Promises in the\n\t * iterable. Iterable values that are not promises are converted to promises using Promise.resolve.\n\t *\n\t * @example\n\t * Promise.all([ Promise.resolve('foo'), 'bar' ]).then(function (value) {\n\t *     value[0] === 'foo'; // true\n\t *     value[1] === 'bar'; // true\n\t * });\n\t *\n\t * @example\n\t * Promise.all({\n\t *     foo: Promise.resolve('foo'),\n\t *     bar: 'bar'\n\t * }).then((value) => {\n\t *     value.foo === 'foo'; // true\n\t *     value.bar === 'bar'; // true\n\t * });\n\t */\n\t/* istanbul ignore next */\n\tstatic all<T>(iterable: (T | Thenable<T>)[] | Iterable<(T | Thenable<T>)>): Promise<T[]> {\n\t\tthrow new Error();\n\t};\n\n\t/**\n\t * Converts an iterable object containing promises into a single promise that resolves or rejects as soon as one of\n\t * the promises in the iterable resolves or rejects, with the value of the resolved or rejected promise. Values in\n\t * the iterable that are not Promises are converted to Promises with Promise.resolve.\n\t *\n\t * @example\n\t * Promise.race([ Promise.resolve('foo'), Promise.resolve('bar') ]).then((value) => {\n\t *     value === 'foo'; // true\n\t * });\n\t *\n\t * @example\n\t * Promise.race({\n\t *     foo: Promise.resolve('foo'),\n\t *     bar: Promise.resolve('bar')\n\t * }).then((value) => {\n\t *     value === 'foo'; // true\n\t * });\n\t */\n\t/* istanbul ignore next */\n\tstatic race<T>(iterable: Iterable<(T | Thenable<T>)> |  (T | Thenable<T>)[]): Promise<T> {\n\t\tthrow new Error();\n\t}\n\n\t/**\n\t * Creates a new promise that is rejected with the given error.\n\t */\n\t/* istanbul ignore next */\n\tstatic reject<T>(reason?: any): Promise<any> {\n\t\tthrow new Error();\n\t}\n\n\t/**\n\t * Creates a new promise that is resolved with the given value.\n\t */\n\tstatic resolve(): Promise<void>;\n\tstatic resolve<T>(value: (T | Thenable<T>)): Promise<T>;\n\t/* istanbul ignore next */\n\tstatic resolve<T>(value?: any): Promise<T> {\n\t\tthrow new Error();\n\t}\n\n\t/**\n\t * Adds a callback to the promise to be invoked when the asynchronous operation throws an error.\n\t */\n\tcatch(onRejected: (reason: Error) => T | Thenable<T> | void): Promise<T>;\n\t/* istanbul ignore next */\n\tcatch<U>(onRejected: (reason: Error) => U | Thenable<U>): Promise<U> {\n\t\tthrow new Error();\n\t}\n\n\tthen<U, V>(onFulfilled: ((value: T) => (U | Thenable<U> | undefined)) | undefined, onRejected: (reason: Error) => (V | Thenable<V>)): Promise<U | V>;\n\tthen<U>(onFulfilled?: ((value: T) => (U | Thenable<U> | undefined)) | undefined, onRejected?: (reason: Error) => void): Promise<U>;\n\t/* istanbul ignore next */\n\tthen<U>(onFulfilled?: ((value: T) => (U | Thenable<U> | undefined)) | undefined, onRejected?: (reason: Error) => (U | Thenable<U>)): Promise<U> {\n\t\tthrow new Error();\n\t}\n}\n\nglobal.Promise = has('es6-promise') ? global.Promise : Shim.Promise;\n\ndeclare global {\n\tclass Promise<T> implements Thenable<T> {\n\t\t/**\n\t\t * Creates a new Promise.\n\t\t *\n\t\t * @constructor\n\t\t *\n\t\t * @param executor\n\t\t * The executor function is called immediately when the Promise is instantiated. It is responsible for\n\t\t * starting the asynchronous operation when it is invoked.\n\t\t *\n\t\t * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n\t\t * successfully, or the `reject` function when the operation fails.\n\t\t */\n\t\tconstructor(executor: Executor<T>);\n\n\t\t/**\n\t\t * Converts an iterable object containing promises into a single promise that resolves to a new iterable object\n\t\t * containing the fulfilled values of all the promises in the iterable, in the same order as the Promises in the\n\t\t * iterable. Iterable values that are not promises are converted to promises using Promise.resolve.\n\t\t *\n\t\t * @example\n\t\t * Promise.all([ Promise.resolve('foo'), 'bar' ]).then(function (value) {\n\t\t *     value[0] === 'foo'; // true\n\t\t *     value[1] === 'bar'; // true\n\t\t * });\n\t\t *\n\t\t * @example\n\t\t * Promise.all({\n\t\t *     foo: Promise.resolve('foo'),\n\t\t *     bar: 'bar'\n\t\t * }).then((value) => {\n\t\t *     value.foo === 'foo'; // true\n\t\t *     value.bar === 'bar'; // true\n\t\t * });\n\t\t */\n\t\tstatic all<T>(iterable: (T | Thenable<T>)[] | Iterable<(T | Thenable<T>)>): Promise<T[]>;\n\n\t\t/**\n\t\t * Converts an iterable object containing promises into a single promise that resolves or rejects as soon as one of\n\t\t * the promises in the iterable resolves or rejects, with the value of the resolved or rejected promise. Values in\n\t\t * the iterable that are not Promises are converted to Promises with Promise.resolve.\n\t\t *\n\t\t * @example\n\t\t * Promise.race([ Promise.resolve('foo'), Promise.resolve('bar') ]).then((value) => {\n\t\t *     value === 'foo'; // true\n\t\t * });\n\t\t *\n\t\t * @example\n\t\t * Promise.race({\n\t\t *     foo: Promise.resolve('foo'),\n\t\t *     bar: Promise.resolve('bar')\n\t\t * }).then((value) => {\n\t\t *     value === 'foo'; // true\n\t\t * });\n\t\t */\n\t\tstatic race<T>(iterable: Iterable<(T | Thenable<T>)> |  (T | Thenable<T>)[]): Promise<T>;\n\n\t\t/**\n\t\t * Creates a new promise that is rejected with the given error.\n\t\t */\n\t\tstatic reject<T>(reason?: any): Promise<T>;\n\n\t\t/**\n\t\t * Creates a new promise that is resolved with the given value.\n\t\t */\n\t\tstatic resolve(): Promise<void>;\n\t\tstatic resolve<T>(value: (T | Thenable<T>)): Promise<T>;\n\t\tstatic resolve<T>(value?: any): Promise<T>;\n\n\t\t/**\n\t\t * Adds a callback to the promise to be invoked when the asynchronous operation throws an error.\n\t\t */\n\t\tcatch(onRejected: (reason: Error) => T | Thenable<T> | void): Promise<T>;\n\t\tcatch<U>(onRejected: (reason: Error) => U | Thenable<U>): Promise<U>;\n\n\t\tthen<U, V>(onFulfilled: ((value: T) => (U | Thenable<U> | undefined)) | undefined, onRejected: (reason: Error) => (V | Thenable<V>)): Promise<U | V>;\n\t\tthen<U>(onFulfilled?: ((value: T) => (U | Thenable<U> | undefined)) | undefined, onRejected?: (reason: Error) => void): Promise<U>;\n\t\tthen<U>(onFulfilled?: ((value: T) => (U | Thenable<U> | undefined)) | undefined, onRejected?: (reason: Error) => (U | Thenable<U>)): Promise<U>;\n\t}\n}\n"]}