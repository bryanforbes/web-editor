import { Thenable } from './interfaces';
import { Iterable } from './iterator';
import './Symbol';
/**
 * Executor is the interface for functions used to initialize a Promise.
 */
export interface Executor<T> {
    /**
     * The executor for the promise
     *
     * @param resolve The resolver callback of the promise
     * @param reject The rejector callback of the promise
     */
    (resolve: (value?: T | Thenable<T>) => void, reject: (reason?: any) => void): void;
}
export default class Promise<T> implements Thenable<T> {
    /**
     * Creates a new Promise.
     *
     * @constructor
     *
     * @param executor
     * The executor function is called immediately when the Promise is instantiated. It is responsible for
     * starting the asynchronous operation when it is invoked.
     *
     * The executor must call either the passed `resolve` function when the asynchronous operation has completed
     * successfully, or the `reject` function when the operation fails.
     */
    constructor(executor: Executor<T>);
    /**
     * Converts an iterable object containing promises into a single promise that resolves to a new iterable object
     * containing the fulfilled values of all the promises in the iterable, in the same order as the Promises in the
     * iterable. Iterable values that are not promises are converted to promises using Promise.resolve.
     *
     * @example
     * Promise.all([ Promise.resolve('foo'), 'bar' ]).then(function (value) {
     *     value[0] === 'foo'; // true
     *     value[1] === 'bar'; // true
     * });
     *
     * @example
     * Promise.all({
     *     foo: Promise.resolve('foo'),
     *     bar: 'bar'
     * }).then((value) => {
     *     value.foo === 'foo'; // true
     *     value.bar === 'bar'; // true
     * });
     */
    static all<T>(iterable: (T | Thenable<T>)[] | Iterable<(T | Thenable<T>)>): Promise<T[]>;
    /**
     * Converts an iterable object containing promises into a single promise that resolves or rejects as soon as one of
     * the promises in the iterable resolves or rejects, with the value of the resolved or rejected promise. Values in
     * the iterable that are not Promises are converted to Promises with Promise.resolve.
     *
     * @example
     * Promise.race([ Promise.resolve('foo'), Promise.resolve('bar') ]).then((value) => {
     *     value === 'foo'; // true
     * });
     *
     * @example
     * Promise.race({
     *     foo: Promise.resolve('foo'),
     *     bar: Promise.resolve('bar')
     * }).then((value) => {
     *     value === 'foo'; // true
     * });
     */
    static race<T>(iterable: Iterable<(T | Thenable<T>)> | (T | Thenable<T>)[]): Promise<T>;
    /**
     * Creates a new promise that is rejected with the given error.
     */
    static reject<T>(reason?: any): Promise<any>;
    /**
     * Creates a new promise that is resolved with the given value.
     */
    static resolve(): Promise<void>;
    static resolve<T>(value: (T | Thenable<T>)): Promise<T>;
    /**
     * Adds a callback to the promise to be invoked when the asynchronous operation throws an error.
     */
    catch(onRejected: (reason: Error) => T | Thenable<T> | void): Promise<T>;
    then<U, V>(onFulfilled: ((value: T) => (U | Thenable<U> | undefined)) | undefined, onRejected: (reason: Error) => (V | Thenable<V>)): Promise<U | V>;
    then<U>(onFulfilled?: ((value: T) => (U | Thenable<U> | undefined)) | undefined, onRejected?: (reason: Error) => void): Promise<U>;
}
declare global  {
    class Promise<T> implements Thenable<T> {
        /**
         * Creates a new Promise.
         *
         * @constructor
         *
         * @param executor
         * The executor function is called immediately when the Promise is instantiated. It is responsible for
         * starting the asynchronous operation when it is invoked.
         *
         * The executor must call either the passed `resolve` function when the asynchronous operation has completed
         * successfully, or the `reject` function when the operation fails.
         */
        constructor(executor: Executor<T>);
        /**
         * Converts an iterable object containing promises into a single promise that resolves to a new iterable object
         * containing the fulfilled values of all the promises in the iterable, in the same order as the Promises in the
         * iterable. Iterable values that are not promises are converted to promises using Promise.resolve.
         *
         * @example
         * Promise.all([ Promise.resolve('foo'), 'bar' ]).then(function (value) {
         *     value[0] === 'foo'; // true
         *     value[1] === 'bar'; // true
         * });
         *
         * @example
         * Promise.all({
         *     foo: Promise.resolve('foo'),
         *     bar: 'bar'
         * }).then((value) => {
         *     value.foo === 'foo'; // true
         *     value.bar === 'bar'; // true
         * });
         */
        static all<T>(iterable: (T | Thenable<T>)[] | Iterable<(T | Thenable<T>)>): Promise<T[]>;
        /**
         * Converts an iterable object containing promises into a single promise that resolves or rejects as soon as one of
         * the promises in the iterable resolves or rejects, with the value of the resolved or rejected promise. Values in
         * the iterable that are not Promises are converted to Promises with Promise.resolve.
         *
         * @example
         * Promise.race([ Promise.resolve('foo'), Promise.resolve('bar') ]).then((value) => {
         *     value === 'foo'; // true
         * });
         *
         * @example
         * Promise.race({
         *     foo: Promise.resolve('foo'),
         *     bar: Promise.resolve('bar')
         * }).then((value) => {
         *     value === 'foo'; // true
         * });
         */
        static race<T>(iterable: Iterable<(T | Thenable<T>)> | (T | Thenable<T>)[]): Promise<T>;
        /**
         * Creates a new promise that is rejected with the given error.
         */
        static reject<T>(reason?: any): Promise<T>;
        /**
         * Creates a new promise that is resolved with the given value.
         */
        static resolve(): Promise<void>;
        static resolve<T>(value: (T | Thenable<T>)): Promise<T>;
        static resolve<T>(value?: any): Promise<T>;
        /**
         * Adds a callback to the promise to be invoked when the asynchronous operation throws an error.
         */
        catch(onRejected: (reason: Error) => T | Thenable<T> | void): Promise<T>;
        catch<U>(onRejected: (reason: Error) => U | Thenable<U>): Promise<U>;
        then<U, V>(onFulfilled: ((value: T) => (U | Thenable<U> | undefined)) | undefined, onRejected: (reason: Error) => (V | Thenable<V>)): Promise<U | V>;
        then<U>(onFulfilled?: ((value: T) => (U | Thenable<U> | undefined)) | undefined, onRejected?: (reason: Error) => void): Promise<U>;
        then<U>(onFulfilled?: ((value: T) => (U | Thenable<U> | undefined)) | undefined, onRejected?: (reason: Error) => (U | Thenable<U>)): Promise<U>;
    }
}
