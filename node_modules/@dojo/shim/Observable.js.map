{"version":3,"file":"Observable.js","sourceRoot":"","sources":["Observable.ts"],"names":[],"mappings":"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","sourcesContent":["import { Iterable, forOf, isIterable, isArrayLike } from './iterator';\nimport { hasClass } from './support/decorators';\nimport global from './support/global';\nimport './Symbol';\n\n/**\n * Handles an individual subscription to an Observable.\n */\nexport interface Subscription {\n\t/**\n\t * Whether or not the subscription is closed. Closed subscriptions will not emit values.\n\t */\n\tclosed: boolean;\n\n\t/**\n\t * A function to call to close the subscription. Calling this will call any associated tear down methods.\n\t */\n\tunsubscribe: (() => void);\n}\n\n/**\n * Describes an object that can be subscribed to\n */\nexport interface Subscribable<T> {\n\tsubscribe(observer: Observer<T>): Subscription;\n\tsubscribe(onNext: (value: T) => any, onError?: (error: any) => any, onComplete?: (completeValue?: any) => void): Subscription;\n}\n\n/**\n * Handles events emitted from the subscription\n */\nexport interface Observer<T> {\n\t/**\n\t * Called to handle a single emitted event.\n\t *\n\t * @param {T} value    The value that was emitted.\n\t */\n\tnext?(value: T): any;\n\n\t/**\n\t * An optional method to be called when the subscription starts (before any events are emitted).\n\t * @param observer\n\t */\n\tstart?(observer: Subscription): void;\n\n\t/**\n\t * An optional method to be called if an error occurs during subscription or handling.\n\t *\n\t * @param errorValue    The error\n\t */\n\terror?(errorValue: any): any;\n\n\t/**\n\t * An optional method to be called when the subscription is completed (unless an error occurred and the error method was specified)\n\t *\n\t * @param completeValue    The value passed to the completion method.\n\t */\n\tcomplete?(completeValue?: any): void;\n}\n\n/**\n * An object used to control a single subscription and an observer.\n */\nexport interface SubscriptionObserver<T> {\n\t/**\n\t * Whether or not the subscription is closed.\n\t */\n\treadonly closed: boolean;\n\n\t/**\n\t * Emit an event to the observer.\n\t *\n\t * @param value    The value to be emitted.\n\t */\n\tnext(value: T): any;\n\n\t/**\n\t * Report an error. The subscription will be closed after an error has occurred.\n\t *\n\t * @param errorValue    The error to be reported.\n\t */\n\terror(errorValue: any): any;\n\n\t/**\n\t * Report completion of the subscription. The subscription will be closed, and no new values will be emitted,\n\t * after completion.\n\t *\n\t * @param completeValue?    A value to pass to the completion handler.\n\t */\n\tcomplete(completeValue?: any): void;\n}\n\nexport interface Subscriber<T> {\n\t(observer: SubscriptionObserver<T>): (() => void) | void | { unsubscribe: () => void };\n}\n\n/**\n * An object that implements a Symbol.observerable method.\n */\nexport interface ObservableObject {\n\t[Symbol.observable]: () => any;\n}\n\nnamespace Shim {\n\t/*\n\t * Decorator to mark a single method/property as non-enumerable. ES spec requires pretty much every\n\t * method or property in Subscription, Observable, and SubscriptionObserver to be non-enumerable.\n\t */\n\tfunction nonEnumerable(target: any, key: string | symbol, descriptor: PropertyDescriptor) {\n\t\tdescriptor.enumerable = false;\n\t}\n\n\t/*\n\t * Create a subscription observer for a given observer, and return the subscription.  The \"logic\" for Observerables\n\t * is in here!\n\t */\n\tfunction startSubscription<T>(executor: Subscriber<T>, observer: Observer<T>): Subscription {\n\t\tlet closed = false;\n\t\tlet cleanUp: () => void | undefined;\n\n\t\tfunction unsubscribe() {\n\t\t\tif (!closed) {\n\t\t\t\tclosed = true;\n\n\t\t\t\tif (cleanUp) {\n\t\t\t\t\tcleanUp();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction start(subscriptionObserver: SubscriptionObserver<T>) {\n\t\t\tif (observer.start) {\n\t\t\t\tobserver.start(subscription);\n\t\t\t}\n\n\t\t\tif (closed) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tconst result: any = executor(subscriptionObserver);\n\n\t\t\t\tif (typeof result === 'function') {\n\t\t\t\t\tcleanUp = result;\n\t\t\t\t}\n\t\t\t\telse if (result && 'unsubscribe' in result) {\n\t\t\t\t\tcleanUp = result.unsubscribe;\n\t\t\t\t}\n\t\t\t\telse if (result !== undefined && result !== null) {\n\t\t\t\t\tthrow new TypeError('Subscriber must return a callable or subscription');\n\t\t\t\t}\n\n\t\t\t\tif (closed) {\n\t\t\t\t\tif (cleanUp) {\n\t\t\t\t\t\tcleanUp();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\terror(e);\n\t\t\t}\n\t\t}\n\n\t\tfunction next(value: T): any {\n\t\t\tif (closed) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst next = observer.next;\n\n\t\t\ttry {\n\t\t\t\tif (typeof next === 'function') {\n\t\t\t\t\treturn next(value);\n\t\t\t\t}\n\t\t\t\telse if (next !== undefined && next !== null) {\n\t\t\t\t\tthrow new TypeError('Observer.next is not a function');\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\terror(e);\n\t\t\t}\n\t\t}\n\n\t\tfunction error(errorValue?: any): any {\n\t\t\tif (!closed) {\n\t\t\t\tlet cleanUpError: Error | undefined = undefined;\n\n\t\t\t\ttry {\n\t\t\t\t\tunsubscribe();\n\t\t\t\t}\n\t\t\t\tcatch (e) {\n\t\t\t\t\tcleanUpError = e;\n\t\t\t\t}\n\n\t\t\t\tconst observerError = observer.error;\n\n\t\t\t\tif (observerError !== undefined && observerError !== null) {\n\t\t\t\t\tif (typeof observerError === 'function') {\n\t\t\t\t\t\tconst errorResult = observerError(errorValue);\n\n\t\t\t\t\t\tif (cleanUpError !== undefined) {\n\t\t\t\t\t\t\tthrow cleanUpError;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn errorResult;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow new TypeError('Observer.error is not a function');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (observer.complete) {\n\t\t\t\t\treturn observer.complete(errorValue);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow errorValue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow errorValue;\n\t\t\t}\n\t\t}\n\n\t\tfunction complete(completeValue?: any): any {\n\t\t\tif (!closed) {\n\t\t\t\tlet cleanUpError: Error | undefined = undefined;\n\n\t\t\t\ttry {\n\t\t\t\t\tunsubscribe();\n\t\t\t\t}\n\t\t\t\tcatch (e) {\n\t\t\t\t\tcleanUpError = e;\n\t\t\t\t}\n\n\t\t\t\tconst observerComplete = observer.complete;\n\n\t\t\t\tif (observerComplete !== undefined && observerComplete !== null) {\n\t\t\t\t\tif (typeof observerComplete === 'function') {\n\t\t\t\t\t\tconst completeResult = observerComplete(completeValue);\n\n\t\t\t\t\t\tif (cleanUpError !== undefined) {\n\t\t\t\t\t\t\tthrow cleanUpError;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn completeResult;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow new TypeError('Observer.complete is not a function');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (cleanUpError) {\n\t\t\t\t\tthrow cleanUpError;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst subscription = Object.create(Object.create({}, {\n\t\t\t'closed': {\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: true,\n\t\t\t\tget() {\n\t\t\t\t\treturn closed;\n\t\t\t\t}\n\t\t\t},\n\t\t\t'unsubscribe': {\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: unsubscribe\n\t\t\t}\n\t\t}));\n\n\t\tconst prototype = Object.create({}, {\n\t\t\t'next': {\n\t\t\t\tenumerable: false,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: next,\n\t\t\t\tconfigurable: true\n\t\t\t},\n\t\t\t'error': {\n\t\t\t\tenumerable: false,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: error,\n\t\t\t\tconfigurable: true\n\t\t\t},\n\t\t\t'complete': {\n\t\t\t\tenumerable: false,\n\t\t\t\twritable: true,\n\t\t\t\tvalue: complete,\n\t\t\t\tconfigurable: true\n\t\t\t},\n\t\t\t'closed': {\n\t\t\t\tenumerable: false,\n\t\t\t\tconfigurable: true,\n\t\t\t\tget() {\n\t\t\t\t\treturn closed;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// create the SubscriptionObserver and kick things off\n\t\tstart(<SubscriptionObserver<T>> Object.create(prototype));\n\n\t\t// the ONLY way to control the SubscriptionObserver is with the subscription or from a subscriber\n\t\treturn subscription;\n\t}\n\n\texport class ShimObservable<T> implements Observable<T> {\n\t\tprivate _executor: Subscriber<T>;\n\n\t\t@nonEnumerable\n\t\t[Symbol.observable](): Observable<T> {\n\t\t\treturn this;\n\t\t}\n\n\t\tconstructor(subscriber: Subscriber<T>) {\n\t\t\tif (typeof subscriber !== 'function') {\n\t\t\t\tthrow new TypeError('subscriber is not a function');\n\t\t\t}\n\n\t\t\tthis._executor = subscriber;\n\t\t}\n\n\t\tsubscribe(onNext: (value: T) => any, onError?: (error: any) => any, onComplete?: (value: any) => void): Subscription;\n\t\tsubscribe(observer: Observer<T>): Subscription;\n\t\tsubscribe(observerOrNext: any, onError?: (error: any) => any, onComplete?: (value: any) => void): Subscription;\n\t\t@nonEnumerable\n\t\tsubscribe(observerOrNext: any, ...listeners: any[]) {\n\t\t\tconst [ onError, onComplete ] = [ ...listeners ];\n\n\t\t\tif (!observerOrNext || typeof observerOrNext === 'number' || typeof observerOrNext === 'string' || typeof observerOrNext === 'boolean') {\n\t\t\t\tthrow new TypeError('parameter must be a function or an observer');\n\t\t\t}\n\n\t\t\tlet observer: Observer<T>;\n\n\t\t\tif (typeof observerOrNext === 'function') {\n\t\t\t\tobserver = {\n\t\t\t\t\tnext: observerOrNext\n\t\t\t\t};\n\n\t\t\t\tif (typeof onError === 'function') {\n\t\t\t\t\tobserver.error = onError;\n\t\t\t\t}\n\n\t\t\t\tif (typeof onComplete === 'function') {\n\t\t\t\t\tobserver.complete = onComplete;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tobserver = observerOrNext;\n\t\t\t}\n\n\t\t\treturn startSubscription(this._executor, observer);\n\t\t}\n\n\t\t@nonEnumerable\n\t\tstatic of<U>(...items: U[]): ShimObservable<U> {\n\t\t\tlet constructor: any;\n\n\t\t\tif (typeof this !== 'function') {\n\t\t\t\tconstructor = ShimObservable;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconstructor = this;\n\t\t\t}\n\n\t\t\treturn new constructor((observer: SubscriptionObserver<U>) => {\n\t\t\t\tforOf(items, (o: any) => {\n\t\t\t\t\tobserver.next(o);\n\t\t\t\t});\n\t\t\t\tobserver.complete();\n\t\t\t});\n\t\t}\n\n\t\t@nonEnumerable\n\t\tstatic from<U>(item: Iterable<U> | ArrayLike<U> | Observable<U>): ShimObservable<U> {\n\t\t\tif (item === null || item === undefined) {\n\t\t\t\tthrow new TypeError('item cannot be null or undefined');\n\t\t\t}\n\n\t\t\tlet constructor: any;\n\n\t\t\tif (typeof this !== 'function') {\n\t\t\t\tconstructor = ShimObservable;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconstructor = this;\n\t\t\t}\n\n\t\t\tconst observableSymbol = (<Observable<U>> item)[ Symbol.observable ];\n\n\t\t\tif (observableSymbol !== undefined) {\n\t\t\t\tif (typeof observableSymbol !== 'function') {\n\t\t\t\t\tthrow new TypeError('Symbol.observable must be a function');\n\t\t\t\t}\n\n\t\t\t\tconst result: any = observableSymbol.call(item);\n\n\t\t\t\tif (result === undefined || result === null || typeof result === 'number' || typeof result === 'boolean' || typeof result === 'string') {\n\t\t\t\t\tthrow new TypeError('Return value of Symbol.observable must be object');\n\t\t\t\t}\n\n\t\t\t\tif (result.constructor && result.constructor === this || result instanceof ShimObservable) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\telse if (result.subscribe) {\n\t\t\t\t\treturn new constructor(result.subscribe);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (constructor.of) {\n\t\t\t\t\t\treturn constructor.of(result);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn ShimObservable.of(result);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (isIterable(item) || isArrayLike(item)) {\n\t\t\t\treturn new constructor((observer: SubscriptionObserver<U>) => {\n\t\t\t\t\tforOf(item, (o: any) => {\n\t\t\t\t\t\tobserver.next(o);\n\t\t\t\t\t});\n\t\t\t\t\tobserver.complete();\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new TypeError('Parameter is neither Observable nor Iterable');\n\t\t\t}\n\t\t}\n\t}\n}\n\n@hasClass('es-observable', global.Observable, Shim.ShimObservable)\nexport default class Observable<T> implements ObservableObject {\n\n\t/* istanbul ignore next */\n\t/**\n\t * Create a new observerable with a subscriber function. The subscriber function will get called with a\n\t * SubscriptionObserver parameter for controlling the subscription.  I a function is returned, it will be\n\t * run when the subscription is complete.\n\t *\n\t * @param {Subscriber<T>} subscriber    The subscription function to be called when observers are subscribed\n\t *\n\t * @example\n\t * const source = new Observer<number>((observer) => {\n\t *     observer.next(1);\n\t *     observer.next(2);\n\t *     observer.next(3);\n\t * });\n\t */\n\tconstructor(subscriber: Subscriber<T>) {\n\t}\n\n\t/**\n\t * Registers handlers for handling emitted values, error and completions from the observable, and\n\t * executes the observable's subscriber function, which will take action to set up the underlying data stream.\n\t *\n\t * @param {Observer<T>} observer    The observer object that will handle events\n\t *\n\t * @return {Subscription} A Subscription object that can be used to manage the subscription.\n\t */\n\tsubscribe(observer: Observer<T>): Subscription;\n\n\t/**\n\t * Registers handlers for handling emitted values, error and completions from the observable, and\n\t * executes the observable's subscriber function, which will take action to set up the underlying data stream.\n\t *\n\t * @param onNext        A function to handle an emitted value. Value is passed in as the first parameter to the function.\n\t * @param onError?        A function to handle errors that occur during onNext, or during subscription.\n\t * @param onComplete?    A function that gets called when the subscription is complete, and will not send any more values. This function will also get called if an error occurs and onError is not defined.\n\t *\n\t * @return {Subscription} A Subscription object that can be used to manage the subscription.\n\t */\n\tsubscribe(onNext: (value: T) => any, onError?: (error: any) => any, onComplete?: (completeValue?: any) => void): Subscription;\n\t/* istanbul ignore next */\n\tsubscribe(observerOrNext: any, onError?: (error: any) => any, onComplete?: (compleeValue?: any) => void): Subscription {\n\t\tthrow new Error();\n\t}\n\n\t/* istanbul ignore next */\n\t/**\n\t * Create an Observable from a list of values.\n\t *\n\t * @param {...T} items The values to be emitted\n\t *\n\t * @return {Observable<T>}    An Observable that will emit the specified values\n\t *\n\t * @example\n\t *\n\t * let source = Observable.of(1, 2, 3);\n\t *\n\t * // will emit three separate values, 1, 2, and 3.\n\t */\n\tstatic of<T>(...items: T[]): Observable<T> {\n\t\tthrow new Error();\n\t}\n\n\t/* istanbul ignore next */\n\t/**\n\t * Create an Observable from another object. If the object is in itself Observable, the object will be returned.\n\t * Otherwise, the value will be wrapped in an Observable. If the object is iterable, an Observable will be created\n\t * that emits each item of the iterable.\n\t *\n\t * @param {Iterable<T> | ArrayLike<T> | ObservableObject} item The item to be turned into an Observable\n\t *\n\t * @return {Observable<T>}    An observable for the item you passed in\n\t */\n\tstatic from<T>(item: Iterable<T> | ArrayLike<T> | ObservableObject): Observable<T> {\n\t\tthrow new Error();\n\t}\n\n\t/* istanbul ignore next */\n\t[Symbol.observable](): any {\n\t\tthrow new Error();\n\t}\n}\n"]}