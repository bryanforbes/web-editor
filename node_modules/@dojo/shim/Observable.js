var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./iterator", "./support/decorators", "./support/global", "./Symbol"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var iterator_1 = require("./iterator");
    var decorators_1 = require("./support/decorators");
    var global_1 = require("./support/global");
    require("./Symbol");
    var Shim;
    (function (Shim) {
        /*
         * Decorator to mark a single method/property as non-enumerable. ES spec requires pretty much every
         * method or property in Subscription, Observable, and SubscriptionObserver to be non-enumerable.
         */
        function nonEnumerable(target, key, descriptor) {
            descriptor.enumerable = false;
        }
        /*
         * Create a subscription observer for a given observer, and return the subscription.  The "logic" for Observerables
         * is in here!
         */
        function startSubscription(executor, observer) {
            var closed = false;
            var cleanUp;
            function unsubscribe() {
                if (!closed) {
                    closed = true;
                    if (cleanUp) {
                        cleanUp();
                    }
                }
            }
            function start(subscriptionObserver) {
                if (observer.start) {
                    observer.start(subscription);
                }
                if (closed) {
                    return;
                }
                try {
                    var result = executor(subscriptionObserver);
                    if (typeof result === 'function') {
                        cleanUp = result;
                    }
                    else if (result && 'unsubscribe' in result) {
                        cleanUp = result.unsubscribe;
                    }
                    else if (result !== undefined && result !== null) {
                        throw new TypeError('Subscriber must return a callable or subscription');
                    }
                    if (closed) {
                        if (cleanUp) {
                            cleanUp();
                        }
                    }
                }
                catch (e) {
                    error(e);
                }
            }
            function next(value) {
                if (closed) {
                    return;
                }
                var next = observer.next;
                try {
                    if (typeof next === 'function') {
                        return next(value);
                    }
                    else if (next !== undefined && next !== null) {
                        throw new TypeError('Observer.next is not a function');
                    }
                }
                catch (e) {
                    error(e);
                }
            }
            function error(errorValue) {
                if (!closed) {
                    var cleanUpError = undefined;
                    try {
                        unsubscribe();
                    }
                    catch (e) {
                        cleanUpError = e;
                    }
                    var observerError = observer.error;
                    if (observerError !== undefined && observerError !== null) {
                        if (typeof observerError === 'function') {
                            var errorResult = observerError(errorValue);
                            if (cleanUpError !== undefined) {
                                throw cleanUpError;
                            }
                            return errorResult;
                        }
                        else {
                            throw new TypeError('Observer.error is not a function');
                        }
                    }
                    else if (observer.complete) {
                        return observer.complete(errorValue);
                    }
                    else {
                        throw errorValue;
                    }
                }
                else {
                    throw errorValue;
                }
            }
            function complete(completeValue) {
                if (!closed) {
                    var cleanUpError = undefined;
                    try {
                        unsubscribe();
                    }
                    catch (e) {
                        cleanUpError = e;
                    }
                    var observerComplete = observer.complete;
                    if (observerComplete !== undefined && observerComplete !== null) {
                        if (typeof observerComplete === 'function') {
                            var completeResult = observerComplete(completeValue);
                            if (cleanUpError !== undefined) {
                                throw cleanUpError;
                            }
                            return completeResult;
                        }
                        else {
                            throw new TypeError('Observer.complete is not a function');
                        }
                    }
                    else if (cleanUpError) {
                        throw cleanUpError;
                    }
                }
            }
            var subscription = Object.create(Object.create({}, {
                'closed': {
                    enumerable: false,
                    configurable: true,
                    get: function () {
                        return closed;
                    }
                },
                'unsubscribe': {
                    enumerable: false,
                    configurable: true,
                    writable: true,
                    value: unsubscribe
                }
            }));
            var prototype = Object.create({}, {
                'next': {
                    enumerable: false,
                    writable: true,
                    value: next,
                    configurable: true
                },
                'error': {
                    enumerable: false,
                    writable: true,
                    value: error,
                    configurable: true
                },
                'complete': {
                    enumerable: false,
                    writable: true,
                    value: complete,
                    configurable: true
                },
                'closed': {
                    enumerable: false,
                    configurable: true,
                    get: function () {
                        return closed;
                    }
                }
            });
            // create the SubscriptionObserver and kick things off
            start(Object.create(prototype));
            // the ONLY way to control the SubscriptionObserver is with the subscription or from a subscriber
            return subscription;
        }
        var ShimObservable = (function () {
            function ShimObservable(subscriber) {
                if (typeof subscriber !== 'function') {
                    throw new TypeError('subscriber is not a function');
                }
                this._executor = subscriber;
            }
            ShimObservable.prototype[_a = Symbol.observable] = function () {
                return this;
            };
            ShimObservable.prototype.subscribe = function (observerOrNext) {
                var listeners = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    listeners[_i - 1] = arguments[_i];
                }
                var _a = listeners.slice(), onError = _a[0], onComplete = _a[1];
                if (!observerOrNext || typeof observerOrNext === 'number' || typeof observerOrNext === 'string' || typeof observerOrNext === 'boolean') {
                    throw new TypeError('parameter must be a function or an observer');
                }
                var observer;
                if (typeof observerOrNext === 'function') {
                    observer = {
                        next: observerOrNext
                    };
                    if (typeof onError === 'function') {
                        observer.error = onError;
                    }
                    if (typeof onComplete === 'function') {
                        observer.complete = onComplete;
                    }
                }
                else {
                    observer = observerOrNext;
                }
                return startSubscription(this._executor, observer);
            };
            ShimObservable.of = function () {
                var items = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    items[_i] = arguments[_i];
                }
                var constructor;
                if (typeof this !== 'function') {
                    constructor = ShimObservable;
                }
                else {
                    constructor = this;
                }
                return new constructor(function (observer) {
                    iterator_1.forOf(items, function (o) {
                        observer.next(o);
                    });
                    observer.complete();
                });
            };
            ShimObservable.from = function (item) {
                if (item === null || item === undefined) {
                    throw new TypeError('item cannot be null or undefined');
                }
                var constructor;
                if (typeof this !== 'function') {
                    constructor = ShimObservable;
                }
                else {
                    constructor = this;
                }
                var observableSymbol = item[Symbol.observable];
                if (observableSymbol !== undefined) {
                    if (typeof observableSymbol !== 'function') {
                        throw new TypeError('Symbol.observable must be a function');
                    }
                    var result = observableSymbol.call(item);
                    if (result === undefined || result === null || typeof result === 'number' || typeof result === 'boolean' || typeof result === 'string') {
                        throw new TypeError('Return value of Symbol.observable must be object');
                    }
                    if (result.constructor && result.constructor === this || result instanceof ShimObservable) {
                        return result;
                    }
                    else if (result.subscribe) {
                        return new constructor(result.subscribe);
                    }
                    else {
                        if (constructor.of) {
                            return constructor.of(result);
                        }
                        else {
                            return ShimObservable.of(result);
                        }
                    }
                }
                else if (iterator_1.isIterable(item) || iterator_1.isArrayLike(item)) {
                    return new constructor(function (observer) {
                        iterator_1.forOf(item, function (o) {
                            observer.next(o);
                        });
                        observer.complete();
                    });
                }
                else {
                    throw new TypeError('Parameter is neither Observable nor Iterable');
                }
            };
            return ShimObservable;
        }());
        __decorate([
            nonEnumerable
        ], ShimObservable.prototype, _a, null);
        __decorate([
            nonEnumerable
        ], ShimObservable.prototype, "subscribe", null);
        __decorate([
            nonEnumerable
        ], ShimObservable, "of", null);
        __decorate([
            nonEnumerable
        ], ShimObservable, "from", null);
        Shim.ShimObservable = ShimObservable;
        var _a;
    })(Shim || (Shim = {}));
    var Observable = (function () {
        /* istanbul ignore next */
        /**
         * Create a new observerable with a subscriber function. The subscriber function will get called with a
         * SubscriptionObserver parameter for controlling the subscription.  I a function is returned, it will be
         * run when the subscription is complete.
         *
         * @param {Subscriber<T>} subscriber    The subscription function to be called when observers are subscribed
         *
         * @example
         * const source = new Observer<number>((observer) => {
         *     observer.next(1);
         *     observer.next(2);
         *     observer.next(3);
         * });
         */
        function Observable(subscriber) {
        }
        /* istanbul ignore next */
        Observable.prototype.subscribe = function (observerOrNext, onError, onComplete) {
            throw new Error();
        };
        /* istanbul ignore next */
        /**
         * Create an Observable from a list of values.
         *
         * @param {...T} items The values to be emitted
         *
         * @return {Observable<T>}    An Observable that will emit the specified values
         *
         * @example
         *
         * let source = Observable.of(1, 2, 3);
         *
         * // will emit three separate values, 1, 2, and 3.
         */
        Observable.of = function () {
            var items = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                items[_i] = arguments[_i];
            }
            throw new Error();
        };
        /* istanbul ignore next */
        /**
         * Create an Observable from another object. If the object is in itself Observable, the object will be returned.
         * Otherwise, the value will be wrapped in an Observable. If the object is iterable, an Observable will be created
         * that emits each item of the iterable.
         *
         * @param {Iterable<T> | ArrayLike<T> | ObservableObject} item The item to be turned into an Observable
         *
         * @return {Observable<T>}    An observable for the item you passed in
         */
        Observable.from = function (item) {
            throw new Error();
        };
        /* istanbul ignore next */
        Observable.prototype[Symbol.observable] = function () {
            throw new Error();
        };
        return Observable;
    }());
    Observable = __decorate([
        decorators_1.hasClass('es-observable', global_1.default.Observable, Shim.ShimObservable)
    ], Observable);
    exports.default = Observable;
});
//# sourceMappingURL=Observable.js.map