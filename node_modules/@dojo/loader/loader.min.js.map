{"version":3,"sources":["loader.ts"],"names":["args","forEach","array","callback","mix","target","source","deep","key","sourceValue","Array","isArray","RegExp","consumePendingCacheInsert","referenceModule","item","pendingCacheInsert","cache","toUrl","getModuleInformation","mid","noop","contextRequire","dependencies","module","undefined","getModule","executed","EXECUTING","has","plugin","result","loadNodeModule","initializeModule","cjs","setExports","injected","error","Error","injectModule","uidGenerator","deps","resolveDependencies","def","gc","guardCheckComplete","bind","executionQueue","push","checkComplete","createRequire","requireModule","require","name","toAbsMid","runMapProgram","targetModuleId","map","i","j","length","test","compactPath","path","segment","pathSegments","replace","split","absolutePathSegments","lastSegment","shift","pop","join","updateModuleIdFromMap","moduleId","moduleMap","mapPrograms","star","mapItem","slice","getPluginInformation","match","pluginResourceId","isPluginLoaded","load","resolvePluginResourceId","req","prid","fix","packageId","pack","config","pkgs","moduleIdInPackage","main","modules","pathMapPrograms","url","location","pid","baseUrl","normalize","passedModuleMatch","mappedModuleMatch","moduleInfo","makeCommonJs","executeModule","indexOf","commonJsExportsModule","console","warn","circularTrace","concat","ABORT_EXECUTION","result_1","executedDependencies","dependency","commonJsRequireModule","exports","commonJsModuleModule","factory","apply","executedSomething","loadQ","pseudoPluginResource","pluginResource","injectPlugin","waitingCount","checkCompleteGuard","module_1","splice","onLoad","unshift","parent","cached","onLoadCallback","node","moduleDefArgs","moduleDefFactory","moduleDefinitionArguments","defineModule","injectUrl","m","moduleToInitialize","initializedModule","id","uri","globalObject","window","global","self","packages","paths","shim","crossOrigin","setGlobals","hasCache","Object","create","document","element","createElement","add","now","force","listenerQueues","emit","type","queue","hasListeners","_i","_a","listener","reportModuleLoadError","details","parentMid","message","src","info","on","remove","process","versions","Packages","configuration","computeMapProgram","value","isValueAMapReplacement","0","1","2","3","sort","left","right","mergeProps","bundles","packageDescriptor","keys","moduleDef","define","arguments","root","globalPath","pathComponent","init","newReturnValue","prototype","call","getElementsByTagName","script","hasAttribute","attr","getAttribute","dojoConfig","JSON","parse","e","Function","thisArg","globalObjectGlobals","_findPath","_nodeModulePaths","localModulePath","nodeRequire","vm_1","fs_1","readFile","data","loadCallback","oldModule","runInThisContext","handler","event","head","removeChild","addEventListener","charset","appendChild","inspect","eval","undef","recursive","undefDeps","mod","defineProperty","get","enumerable","comments","requireCall","originalFactory","module_2","originalModuleId","newModule","value_1","amd","vendor"],"mappings":"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","file":"loader.min.js","sourcesContent":["'use strict';\nimport ModuleShim = DojoLoader.ModuleShim;\nimport Module = DojoLoader.Module;\n\ndeclare const load: (module: string) => any;\ndeclare const Packages: {} | undefined;\n\n(function (args?: string[]): void {\n\tlet globalObject: any = (function (): any {\n\t\tif (typeof window !== 'undefined') {\n\t\t\t// Browsers\n\t\t\treturn window;\n\t\t}\n\t\telse if (typeof global !== 'undefined') {\n\t\t\t// Node\n\t\t\treturn global;\n\t\t}\n\t\telse if (typeof self !== 'undefined') {\n\t\t\t// Web workers\n\t\t\treturn self;\n\t\t}\n\t\treturn {};\n\t})();\n\n\tconst EXECUTING = 'executing';\n\tconst ABORT_EXECUTION: Object = {};\n\t//\n\t// loader state data\n\t//\n\n\t// hash: (mid | url)-->(function | string)\n\t//\n\t// A cache of resources. The resources arrive via a require.cache application, which takes a hash from either\n\t// mid --> function or url --> string. The function associated with mid keys causes the same code to execute as if\n\t// the module was script injected.\n\t//\n\t// Both kinds of key-value pairs are entered into cache via the function consumePendingCache, which may relocate\n\t// keys as given by any mappings *iff* the cache was received as part of a module resource request.\n\tlet cache: DojoLoader.ObjectMap = {};\n\n\tlet checkCompleteGuard = 0;\n\n\t// The configuration passed to the loader\n\tlet config: DojoLoader.Config = {\n\t\tbaseUrl: './',\n\t\tpackages: [],\n\t\tpaths: {},\n\t\tpkgs: {},\n\t\tshim: {},\n\t\tcrossOrigin: false\n\t};\n\n\t// The arguments sent to loader via AMD define().\n\tlet moduleDefinitionArguments: DojoLoader.ModuleDefinitionArguments | undefined = undefined;\n\n\t// The list of modules that need to be evaluated.\n\tlet executionQueue: DojoLoader.Module[] = [];\n\n\tlet executedSomething = false;\n\n\tlet injectUrl: (url: string, callback: (node?: HTMLScriptElement) => void, module: DojoLoader.Module, parent?: DojoLoader.Module) => void;\n\n\t// array of quads as described by computeMapProg; map-key is AMD map key, map-value is AMD map value\n\tlet mapPrograms: DojoLoader.MapRoot = [];\n\n\t// A hash: (mid) --> (module-object) the module namespace\n\t//\n\t// pid: the package identifier to which the module belongs (e.g., \"dojo\"); \"\" indicates the system or default\n\t// \tpackage\n\t// mid: the fully-resolved (i.e., mappings have been applied) module identifier without the package identifier\n\t// \t(e.g., \"dojo/io/script\")\n\t// url: the URL from which the module was retrieved\n\t// pack: the package object of the package to which the module belongs\n\t// executed: false => not executed; EXECUTING => in the process of tranversing deps and running factory;\n\t// \ttrue => factory has been executed\n\t// deps: the dependency array for this module (array of modules objects)\n\t// def: the factory for this module\n\t// result: the result of the running the factory for this module\n\t// injected: true => module has been injected\n\t// load, normalize: plugin functions applicable only for plugins\n\t//\n\t// Modules go through several phases in creation:\n\t//\n\t// 1. Requested: some other module's definition or a require application contained the requested module in\n\t//    its dependency array\n\t//\n\t// 2. Injected: a script element has been appended to the insert-point element demanding the resource implied by\n\t//    the URL\n\t//\n\t// 3. Loaded: the resource injected in [2] has been evaluated.\n\t//\n\t// 4. Defined: the resource contained a define statement that advised the loader about the module.\n\t//\n\t// 5. Evaluated: the module was defined via define and the loader has evaluated the factory and computed a result.\n\tlet modules: { [ moduleId: string ]: DojoLoader.Module | undefined; } = {};\n\n\t// list of (from-path, to-path, regex, length) derived from paths;\n\t// a \"program\" to apply paths; see computeMapProg\n\tlet pathMapPrograms: DojoLoader.PathMap[] = [];\n\n\t// hash: (mid | url)-->(function | string)\n\t//\n\t// Gives a set of cache modules pending entry into cache. When cached modules are published to the loader, they are\n\t// entered into pendingCacheInsert; modules are then pressed into cache upon (1) AMD define or (2) upon receiving\n\t// another independent set of cached modules. (1) is the usual case, and this case allows normalizing mids given\n\t// in the pending cache for the local configuration, possibly relocating modules.\n\tlet pendingCacheInsert: { [moduleId: string]: any; } = {};\n\n\tlet setGlobals: (require: DojoLoader.RootRequire, define: DojoLoader.Define) => void;\n\n\tlet uidGenerator = 0;\n\n\t// the number of modules the loader has injected but has not seen defined\n\tlet waitingCount = 0;\n\n\tconst has: DojoLoader.Has = (function (): DojoLoader.Has {\n\t\tconst hasCache: { [ name: string ]: any; } = Object.create(null);\n\t\tconst global: Window = globalObject;\n\t\tconst document: HTMLDocument = global.document;\n\t\tconst element: HTMLDivElement = document && document.createElement('div');\n\n\t\tconst has: DojoLoader.Has = <DojoLoader.Has> function(name: string): any {\n\t\t\treturn typeof hasCache[name] === 'function' ?\n\t\t\t\t(hasCache[name] = hasCache[name](global, document, element)) : hasCache[name];\n\t\t};\n\n\t\thas.add = function (name: string, test: any, now: boolean, force: boolean): void {\n\t\t\t(!(name in hasCache) || force) && (hasCache[name] = test);\n\t\t\tnow && has(name);\n\t\t};\n\n\t\treturn has;\n\t})();\n\n\tconst requireModule: DojoLoader.RootRequire =\n\t\t<DojoLoader.RootRequire> function (dependencies: any, callback?: DojoLoader.RequireCallback): DojoLoader.Module {\n\t\t\treturn contextRequire(dependencies, callback);\n\t\t};\n\n\tconst listenerQueues: { [queue: string]: ((...args: any[]) => void)[] } = {};\n\n\tconst emit = function(type: DojoLoader.SignalType, args: {}): number | boolean {\n\t\tlet queue = listenerQueues[type];\n\t\tlet hasListeners = queue && queue.length;\n\n\t\tif (hasListeners) {\n\t\t\tfor (let listener of queue.slice(0)) {\n\t\t\t\tlistener.apply(null, Array.isArray(args) ? args : [args]);\n\t\t\t}\n\t\t}\n\n\t\treturn hasListeners;\n\t};\n\n\tconst reportModuleLoadError = function (parent: DojoLoader.Module | undefined, module: DojoLoader.Module, url: string, details?: string): void {\n\t\tconst parentMid = (parent ? ` (parent: ${parent.mid})` : '');\n\t\tconst message = `Failed to load module ${module.mid} from ${url}${parentMid}`;\n\t\tconst error = mix<DojoLoader.LoaderError>(new Error(message), {\n\t\t\tsrc: 'dojo/loader',\n\t\t\tinfo: {\n\t\t\t\tmodule,\n\t\t\t\turl,\n\t\t\t\tparentMid,\n\t\t\t\tdetails\n\t\t\t}\n\t\t});\n\n\t\tif (!emit('error', error)) { throw error; };\n\t};\n\n\tconst on = function(type: string, listener: (error: DojoLoader.LoaderError) => void): { remove: () => void } {\n\t\tlet queue = listenerQueues[type] || (listenerQueues[type] = []);\n\n\t\tqueue.push(listener);\n\n\t\treturn {\n\t\t\tremove(): void {\n\t\t\t\tqueue.splice(queue.indexOf(listener), 1);\n\t\t\t}\n\t\t};\n\t};\n\n\trequireModule.has = has;\n\trequireModule.on = on;\n\n\thas.add('host-browser', typeof document !== 'undefined' && typeof location !== 'undefined');\n\thas.add('host-node', typeof process === 'object' && process.versions && process.versions.node);\n\thas.add('host-nashorn', typeof load === 'function' && typeof Packages !== 'undefined');\n\thas.add('debug', true);\n\n\thas.add('loader-configurable', true);\n\thas.add('loader-config-attribute', true);\n\tif (has('loader-configurable')) {\n\t\t/**\n\t\t * Configures the loader.\n\t\t *\n\t\t * @param {{ ?baseUrl: string, ?map: Object, ?packages: Array.<({ name, ?location, ?main }|string)> }} config\n\t\t * The configuration data.\n\t\t */\n\t\trequireModule.config = function (configuration: DojoLoader.Config): void {\n\t\t\t// Make sure baseUrl ends in a slash\n\t\t\tif (configuration.baseUrl) {\n\t\t\t\tconfiguration.baseUrl = configuration.baseUrl.replace(/\\/*$/, '/');\n\t\t\t}\n\n\t\t\tconst mergeProps: DojoLoader.ObjectMap = {\n\t\t\t\tpaths: true,\n\t\t\t\tbundles: true,\n\t\t\t\tconfig: true,\n\t\t\t\tmap: true\n\t\t\t};\n\n\t\t\t// Copy configuration over to config object\n\t\t\tfor (let key in configuration) {\n\t\t\t\tconst value = (<DojoLoader.ObjectMap> configuration)[key];\n\t\t\t\tif (mergeProps[key]) {\n\t\t\t\t\tif (!(<DojoLoader.ObjectMap> config)[key]) {\n\t\t\t\t\t\t(<DojoLoader.ObjectMap> config)[key] = {};\n\t\t\t\t\t}\n\t\t\t\t\tmix((<DojoLoader.ObjectMap> config)[key], value, true);\n\t\t\t\t} else {\n\t\t\t\t\t(<DojoLoader.ObjectMap> config)[key] = value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// TODO: Expose all properties on req as getter/setters? Plugin modules like dojo/node being able to\n\t\t\t// retrieve baseUrl is important. baseUrl is defined as a getter currently.\n\n\t\t\tforEach(configuration.packages || [], function (packageDescriptor: DojoLoader.Package): void {\n\t\t\t\t// Allow shorthand package definition, where name and location are the same\n\t\t\t\tif (typeof packageDescriptor === 'string') {\n\t\t\t\t\tpackageDescriptor = { name: <string> packageDescriptor, location: <string> packageDescriptor };\n\t\t\t\t}\n\n\t\t\t\tif (packageDescriptor.location != null) {\n\t\t\t\t\tpackageDescriptor.location = packageDescriptor.location.replace(/\\/*$/, '/');\n\t\t\t\t}\n\n\t\t\t\tif (config && config.pkgs && packageDescriptor.name) {\n\t\t\t\t\tconfig.pkgs[packageDescriptor.name] = packageDescriptor;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfunction computeMapProgram(map: DojoLoader.ModuleMapItem | undefined): DojoLoader.MapItem[] {\n\t\t\t\t// This method takes a map as represented by a JavaScript object and initializes an array of\n\t\t\t\t// arrays of (map-key, map-value, regex-for-map-key, length-of-map-key), sorted decreasing by length-\n\t\t\t\t// of-map-key. The regex looks for the map-key followed by either \"/\" or end-of-string at the beginning\n\t\t\t\t// of a the search source.\n\t\t\t\t//\n\t\t\t\t// Maps look like this:\n\t\t\t\t//\n\t\t\t\t// map: { C: { D: E } }\n\t\t\t\t//    A\tB\n\t\t\t\t//\n\t\t\t\t// The computed mapping is a 4-array deep tree, where the outermost array corresponds to the source\n\t\t\t\t// mapping object A, the 2nd level arrays each correspond to one of the source mappings C -> B, the 3rd\n\t\t\t\t// level arrays correspond to each destination mapping object B, and the innermost arrays each\n\t\t\t\t// correspond to one of the destination mappings D -> E.\n\t\t\t\t//\n\t\t\t\t// So, the overall structure looks like this:\n\t\t\t\t//\n\t\t\t\t// mapPrograms = [ source mapping array, source mapping array, ... ]\n\t\t\t\t// source mapping array = [\n\t\t\t\t//     source module id,\n\t\t\t\t//     [ destination mapping array, destination mapping array, ... ],\n\t\t\t\t//     RegExp that matches on source module id,\n\t\t\t\t//     source module id length\n\t\t\t\t// ]\n\t\t\t\t// destination mapping array = [\n\t\t\t\t//     original module id,\n\t\t\t\t//     destination module id,\n\t\t\t\t//     RegExp that matches on original module id,\n\t\t\t\t//     original module id length\n\t\t\t\t// ]\n\n\t\t\t\tconst result: DojoLoader.MapItem[] = [];\n\n\t\t\t\tif (map) {\n\t\t\t\t\tfor (let moduleId in map) {\n\t\t\t\t\t\tconst value: any = (<any> map)[moduleId];\n\t\t\t\t\t\tconst isValueAMapReplacement: boolean = typeof value === 'object';\n\n\t\t\t\t\t\tconst item = <DojoLoader.MapItem> {\n\t\t\t\t\t\t\t0: moduleId,\n\t\t\t\t\t\t\t1: isValueAMapReplacement ? computeMapProgram(value) : value,\n\t\t\t\t\t\t\t2: new RegExp('^' + moduleId.replace(/[-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, '\\\\$&') + '(?:\\/|$)'),\n\t\t\t\t\t\t\t3: moduleId.length\n\t\t\t\t\t\t};\n\t\t\t\t\t\tresult.push(item);\n\n\t\t\t\t\t\tif (isValueAMapReplacement && moduleId === '*') {\n\t\t\t\t\t\t\t(<DojoLoader.MapRoot> result).star = item[1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tresult.sort(function (left: DojoLoader.MapItem, right: DojoLoader.MapItem): number {\n\t\t\t\t\treturn right[3] - left[3];\n\t\t\t\t});\n\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\t// FIXME this is a down-cast.\n\t\t\t// computeMapProgram => MapItem[] => mapPrograms: MapSource[]\n\t\t\t// MapSource[1] => MapReplacement[] is more specific than MapItems[1] => any\n\t\t\tmapPrograms = computeMapProgram(config.map);\n\n\t\t\t// Note that old paths will get destroyed if reconfigured\n\t\t\tconfiguration.paths && (pathMapPrograms = computeMapProgram(configuration.paths));\n\n\t\t\t// shim API\n\t\t\tif (config.shim) {\n\t\t\t\tObject.keys(config.shim).forEach((moduleId) => {\n\t\t\t\t\tlet moduleDef: ModuleShim = (config.shim || {})[ moduleId ];\n\n\t\t\t\t\t// using shorthand module syntax, convert to full syntax\n\t\t\t\t\tif (Array.isArray(moduleDef)) {\n\t\t\t\t\t\tmoduleDef = {\n\t\t\t\t\t\t\tdeps: <string[]> moduleDef\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\tdefine(moduleId, moduleDef.deps || [], function (...dependencies) {\n\t\t\t\t\t\tlet root: any;\n\n\t\t\t\t\t\tlet globalPath = moduleDef.exports;\n\n\t\t\t\t\t\tif (globalPath) {\n\t\t\t\t\t\t\troot = globalObject;\n\n\t\t\t\t\t\t\tglobalPath.split('.').forEach((pathComponent) => {\n\t\t\t\t\t\t\t\tif (!(pathComponent in root)) {\n\t\t\t\t\t\t\t\t\tthrow new Error(`Tried to find ${globalPath} but it did not exist`);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\troot = root[ pathComponent ];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (moduleDef.init) {\n\t\t\t\t\t\t\tlet newReturnValue: any = moduleDef.init(...dependencies);\n\n\t\t\t\t\t\t\tif (newReturnValue !== undefined) {\n\t\t\t\t\t\t\t\troot = newReturnValue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn root;\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\tif (has('loader-config-attribute') && has('host-browser')) {\n\t\t\tArray.prototype.slice.call(document.getElementsByTagName('script'), 0).forEach((script: HTMLScriptElement) => {\n\t\t\t\tif (script.hasAttribute('data-loader-config')) {\n\t\t\t\t\tconst attr = script.getAttribute('data-loader-config');\n\t\t\t\t\tlet dojoConfig: DojoLoader.Config | null = null;\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdojoConfig = <DojoLoader.Config> JSON.parse(`{ ${attr} }`);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\tconsole.error('Unable to parse data-loader-config, ' + attr);\n\t\t\t\t\t\tconsole.error(e);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (dojoConfig !== null) {\n\t\t\t\t\t\trequireModule.config(dojoConfig);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction forEach<T>(array: T[], callback: (value: T, index: number, array: T[]) => void): void {\n\t\tarray && array.forEach(callback);\n\t}\n\n\tfunction mix<T extends {}>(target: {}, source: {}, deep?: boolean): T {\n\t\tif (source) {\n\t\t\tfor (let key in source) {\n\t\t\t\tlet sourceValue = (<DojoLoader.ObjectMap> source)[key];\n\n\t\t\t\tif (deep && typeof sourceValue === 'object' &&\n\t\t\t\t\t!Array.isArray(sourceValue) && !(sourceValue instanceof RegExp)) {\n\n\t\t\t\t\tif (!(<DojoLoader.ObjectMap> target)[key]) {\n\t\t\t\t\t\t(<DojoLoader.ObjectMap> target)[key] = {};\n\t\t\t\t\t}\n\t\t\t\t\tmix((<DojoLoader.ObjectMap> target)[key], sourceValue, true);\n\t\t\t\t} else {\n\t\t\t\t\t(<DojoLoader.ObjectMap> target)[key] = sourceValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn <T> target;\n\t}\n\n\tfunction consumePendingCacheInsert(referenceModule?: DojoLoader.Module): void {\n\t\tlet item: any;\n\n\t\tfor (let key in pendingCacheInsert) {\n\t\t\titem = pendingCacheInsert[key];\n\n\t\t\tcache[\n\t\t\t\ttypeof item === 'string' ? toUrl(key, referenceModule) : getModuleInformation(key, referenceModule).mid\n\t\t\t] = item;\n\t\t}\n\n\t\tpendingCacheInsert = {};\n\t}\n\n\tfunction noop(): void {};\n\n\tlet loadNodeModule: (moduleId: string, parent?: DojoLoader.Module) => any = noop;\n\n\tfunction contextRequire(moduleId: string, unused?: void, referenceModule?: DojoLoader.Module): DojoLoader.Module;\n\tfunction contextRequire(dependencies: string[], callback?: DojoLoader.RequireCallback, referenceModule?: DojoLoader.Module): DojoLoader.Module;\n\tfunction contextRequire(dependencies: string | string[], callback: any, referenceModule?: DojoLoader.Module): DojoLoader.Module | undefined {\n\t\tlet module: DojoLoader.Module | undefined = undefined;\n\t\tif (typeof dependencies === 'string') {\n\t\t\tmodule = getModule(dependencies, referenceModule);\n\t\t\tif (module.executed !== true && module.executed !== EXECUTING) {\n\t\t\t\tif (has('host-node') && !module.plugin) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet result = loadNodeModule(module.mid, referenceModule);\n\n\t\t\t\t\t\tinitializeModule(module, [], undefined);\n\t\t\t\t\t\tmodule.result = result;\n\t\t\t\t\t\tmodule.cjs.setExports(result);\n\t\t\t\t\t\tmodule.executed = true;\n\t\t\t\t\t\tmodule.injected = true;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (error) {\n\t\t\t\t\t\tthrow new Error('Attempt to require unloaded module ' + module.mid);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (module.plugin) {\n\t\t\t\t\tinjectModule(module, undefined);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Assign the result of the module to `module`\n\t\t\t// otherwise require('moduleId') returns the internal\n\t\t\t// module representation\n\t\t\tmodule = module.result;\n\t\t}\n\t\telse if (Array.isArray(dependencies)) {\n\t\t\t// signature is (requestList [,callback])\n\t\t\t// construct a synthetic module to control execution of the requestList, and, optionally, callback\n\t\t\tmodule = getModuleInformation('*' + (++uidGenerator));\n\t\t\tmix(module, {\n\t\t\t\tdeps: resolveDependencies(dependencies, module, referenceModule),\n\t\t\t\tdef: callback || {},\n\t\t\t\tgc: true // garbage collect\n\t\t\t});\n\t\t\tguardCheckComplete(function (): void {\n\t\t\t\tforEach(module ? module.deps : [], injectModule.bind(null, module));\n\t\t\t});\n\t\t\texecutionQueue.push(module);\n\t\t\tcheckComplete();\n\t\t}\n\t\treturn module;\n\t}\n\n\tfunction createRequire(module: DojoLoader.Module | undefined): DojoLoader.Require | undefined {\n\t\tlet result: DojoLoader.Require | undefined = (!module && requireModule) || (module && module.require);\n\t\tif (!result && module) {\n\t\t\tmodule.require = result = <DojoLoader.Require> function (dependencies: any, callback: any): DojoLoader.Module {\n\t\t\t\treturn contextRequire(dependencies, callback, module);\n\t\t\t};\n\t\t\tmix(mix(result, requireModule), {\n\t\t\t\ttoUrl: function (name: string): string {\n\t\t\t\t\treturn toUrl(name, module);\n\t\t\t\t},\n\t\t\t\ttoAbsMid: function (mid: string): string {\n\t\t\t\t\treturn toAbsMid(mid, module);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn result;\n\t}\n\n\tfunction runMapProgram(targetModuleId: string, map?: DojoLoader.MapItem[]): DojoLoader.MapSource | undefined {\n\t\t// search for targetModuleId in map; return the map item if found; falsy otherwise\n\t\tif (map) {\n\t\t\tfor (let i = 0, j = map.length; i < j; ++i) {\n\t\t\t\tif (map[i][2].test(targetModuleId)) {\n\t\t\t\t\treturn map[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tfunction compactPath(path: string): string {\n\t\tconst pathSegments: string[] = path.replace(/\\\\/g, '/').split('/');\n\t\tlet absolutePathSegments: (string|undefined)[] = [];\n\t\tlet segment: string | undefined;\n\t\tlet lastSegment: string | undefined = '';\n\n\t\twhile (pathSegments.length) {\n\t\t\tsegment = pathSegments.shift();\n\t\t\tif (segment === '..' && absolutePathSegments.length && lastSegment !== '..') {\n\t\t\t\tabsolutePathSegments.pop();\n\t\t\t\tlastSegment = absolutePathSegments[absolutePathSegments.length - 1];\n\t\t\t}\n\t\t\telse if (segment !== '.') {\n\t\t\t\tabsolutePathSegments.push((lastSegment = segment));\n\t\t\t} // else ignore \".\"\n\t\t}\n\n\t\treturn absolutePathSegments.join('/');\n\t}\n\n\tfunction updateModuleIdFromMap(moduleId: string, referenceModule?: DojoLoader.Module): string {\n\t\t// relative module ids are relative to the referenceModule; get rid of any dots\n\t\tmoduleId = compactPath(/^\\./.test(moduleId) && referenceModule ?\n\t\t\t(referenceModule.mid + '/../' + moduleId) : moduleId);\n\t\t// at this point, moduleId is an absolute moduleId\n\n\t\t// if there is a reference module, then use its module map, if one exists; otherwise, use the global map.\n\t\t// see computeMapProg for more information on the structure of the map arrays\n\t\tlet moduleMap: DojoLoader.MapItem | undefined = referenceModule && runMapProgram(referenceModule.mid, mapPrograms);\n\t\tmoduleMap = moduleMap ? moduleMap[1] : mapPrograms.star;\n\n\t\tlet mapItem: DojoLoader.MapItem | undefined;\n\t\tif ((mapItem = runMapProgram(moduleId, moduleMap))) {\n\t\t\tmoduleId = mapItem[1] + moduleId.slice(mapItem[3]);\n\t\t}\n\n\t\treturn moduleId;\n\t}\n\n\tfunction getPluginInformation(moduleId: string, match: string[], referenceModule?: DojoLoader.Module): DojoLoader.Module {\n\t\tconst plugin = getModule(match[1], referenceModule);\n\t\tconst isPluginLoaded = Boolean(plugin.load);\n\n\t\tconst contextRequire = createRequire(referenceModule);\n\n\t\tlet pluginResourceId: string;\n\t\tif (isPluginLoaded) {\n\t\t\tpluginResourceId = resolvePluginResourceId(plugin, match[2], contextRequire);\n\t\t\tmoduleId = (plugin.mid + '!' + pluginResourceId);\n\t\t}\n\t\telse {\n\t\t\t// if not loaded, need to mark in a way that it will get properly resolved later\n\t\t\tpluginResourceId = match[2];\n\t\t\tmoduleId = plugin.mid + '!' + (++uidGenerator) + '!*';\n\t\t}\n\t\treturn <DojoLoader.Module> <any> {\n\t\t\tplugin: plugin,\n\t\t\tmid: moduleId,\n\t\t\treq: contextRequire,\n\t\t\tprid: pluginResourceId,\n\t\t\tfix: !isPluginLoaded\n\t\t};\n\t}\n\n\tfunction getModuleInformation(moduleId: string, referenceModule?: DojoLoader.Module): DojoLoader.Module {\n\t\tlet match = moduleId.match(/^([^\\/]+)(\\/(.+))?$/);\n\t\tlet packageId = match ? match[1] : '';\n\t\tlet pack = config && config.pkgs ? config.pkgs[packageId] : {};\n\t\tlet moduleIdInPackage = '';\n\n\t\tif (pack) {\n\t\t\tmoduleId = packageId + '/' + (moduleIdInPackage = ((match && match[3]) || pack.main || 'main'));\n\t\t}\n\t\telse {\n\t\t\tpackageId = '';\n\t\t}\n\n\t\tlet module = modules[moduleId];\n\t\tif (!(module)) {\n\t\t\tlet mapItem = runMapProgram(moduleId, pathMapPrograms);\n\t\t\tlet url = mapItem ? mapItem[1] + moduleId.slice(mapItem[3]) : (packageId ? pack.location + moduleIdInPackage : moduleId);\n\t\t\tmodule = <DojoLoader.Module> <any> {\n\t\t\t\tpid: packageId,\n\t\t\t\tmid: moduleId,\n\t\t\t\tpack: pack,\n\t\t\t\turl: compactPath(\n\t\t\t\t\t// absolute urls should not be prefixed with baseUrl\n\t\t\t\t\t(/^(?:\\/|\\w+:)/.test(url) ? '' : config.baseUrl) +\n\t\t\t\t\turl +\n\t\t\t\t\t// urls with a javascript extension should not have another one added\n\t\t\t\t\t(/\\.js(?:\\?[^?]*)?$/.test(url) ? '' : '.js')\n\t\t\t\t)\n\t\t\t};\n\t\t}\n\n\t\treturn module;\n\t}\n\n\tfunction resolvePluginResourceId(plugin: DojoLoader.Module, pluginResourceId: string, contextRequire?: DojoLoader.Require): string {\n\t\tconst toAbsMid = contextRequire ? contextRequire.toAbsMid : undefined;\n\t\treturn plugin.normalize ? plugin.normalize(pluginResourceId, <any> toAbsMid) : toAbsMid ? toAbsMid(pluginResourceId) : '';\n\t}\n\n\tfunction getModule(moduleId: string, referenceModule?: DojoLoader.Module): DojoLoader.Module {\n\t\t// compute and construct (if necessary) the module implied by the moduleId with respect to referenceModule\n\t\tlet module: DojoLoader.Module;\n\t\tconst pluginRegEx = /^(.+?)\\!(.*)$/;\n\n\t\t// Foreseable situations (where ?-> is a map lookup function)\n\t\t// module\n\t\t// plugin!arg\n\t\t// module ?-> mappedModule\n\t\t// module ?-> mappedPlugin!arg\n\t\t// plugin!arg ?-> mappedPlugin + ! + arg\n\n\t\t// Do inital check on the passed in moduleId\n\t\tconst passedModuleMatch = moduleId.match(pluginRegEx);\n\t\tif (passedModuleMatch) {\n\t\t\t// Passed in moduleId is a plugin, so check the map using only the plugin name\n\t\t\t// then reconstruct using the pluginArgs\n\t\t\tlet pluginId: string = updateModuleIdFromMap(passedModuleMatch[1], referenceModule);\n\t\t\tmoduleId = `${pluginId}!${passedModuleMatch[2]}`;\n\t\t}\n\t\telse {\n\t\t\t// Not a module, so check the map using the full moduleId passed\n\t\t\tmoduleId = updateModuleIdFromMap(moduleId, referenceModule);\n\t\t}\n\n\t\t// Do final check on the mapped module / plugin Id to see what we're dealing with\n\t\tconst mappedModuleMatch = moduleId.match(pluginRegEx);\n\t\tif (mappedModuleMatch) {\n\t\t\tmodule = getPluginInformation(moduleId, mappedModuleMatch, referenceModule);\n\t\t}\n\t\telse {\n\t\t\tmodule = getModuleInformation(moduleId, referenceModule);\n\t\t}\n\n\t\treturn modules[module.mid] || (modules[module.mid] = module);\n\t}\n\n\tfunction toAbsMid(moduleId: string, referenceModule: DojoLoader.Module | undefined): string {\n\t\tmoduleId = updateModuleIdFromMap(moduleId, referenceModule);\n\t\treturn getModuleInformation(moduleId, referenceModule).mid;\n\t}\n\n\tfunction toUrl(name: string, referenceModule: DojoLoader.Module | undefined): string {\n\t\tlet moduleId = name + '/x';\n\t\tmoduleId = updateModuleIdFromMap(moduleId, referenceModule);\n\t\tconst moduleInfo: DojoLoader.Module = getModuleInformation(moduleId, referenceModule);\n\t\tconst url: string = moduleInfo.url;\n\n\t\t// \"/x.js\" since getModuleInfo automatically appends \".js\" and we appended \"/x\" to make name look like a\n\t\t// module id\n\t\treturn url.slice(0, url.length - 5);\n\t}\n\n\tfunction makeCommonJs(mid: string): DojoLoader.Module {\n\t\treturn (modules[mid] = <DojoLoader.Module> <any> {\n\t\t\tmid: mid,\n\t\t\tinjected: true,\n\t\t\texecuted: true\n\t\t});\n\t}\n\tconst commonJsRequireModule: DojoLoader.Module = makeCommonJs('require');\n\tconst commonJsExportsModule: DojoLoader.Module = makeCommonJs('exports');\n\tconst commonJsModuleModule: DojoLoader.Module = makeCommonJs('module');\n\tlet circularTrace: string[];\n\n\thas.add('loader-debug-circular-dependencies', true);\n\tif (has('loader-debug-circular-dependencies')) {\n\t\tcircularTrace = [];\n\t}\n\n\tfunction executeModule(module: DojoLoader.Module): any {\n\t\t// run the dependency array, then run the factory for module\n\t\tif (module.executed === EXECUTING) {\n\t\t\t// for circular dependencies, assume the first module encountered was executed OK\n\t\t\t// modules that circularly depend on a module that has not run its factory will get\n\t\t\t// the premade cjs.exports===module.result. They can take a reference to this object and/or\n\t\t\t// add properties to it. When the module finally runs its factory, the factory can\n\t\t\t// read/write/replace this object. Notice that so long as the object isn't replaced, any\n\t\t\t// reference taken earlier while walking the dependencies list is still valid.\n\t\t\tif (\n\t\t\t\thas('loader-debug-circular-dependencies') &&\n\t\t\t\tmodule.deps.indexOf(commonJsExportsModule) === -1 &&\n\t\t\t\ttypeof console !== 'undefined'\n\t\t\t) {\n\t\t\t\tconsole.warn('Circular dependency: ' + circularTrace.concat(module.mid).join(' -> '));\n\t\t\t}\n\n\t\t\treturn module.result;\n\t\t}\n\n\t\tif (!module.executed) {\n\t\t\t// TODO: This seems like an incorrect condition inference. Originally it was simply !module.def\n\t\t\t// which caused modules with falsy defined values to never execute.\n\t\t\tif (!module.def && !module.deps) {\n\t\t\t\treturn ABORT_EXECUTION;\n\t\t\t}\n\n\t\t\thas('loader-debug-circular-dependencies') && circularTrace.push(module.mid);\n\n\t\t\tconst dependencies: DojoLoader.Module[] = module.deps;\n\t\t\tlet result: any;\n\n\t\t\tmodule.executed = EXECUTING;\n\t\t\tlet executedDependencies = dependencies.map(function (dependency: DojoLoader.Module): any {\n\t\t\t\tif (result !== ABORT_EXECUTION) {\n\t\t\t\t\t// check for keyword dependencies: DojoLoader.require, exports, module; then execute module dependency\n\t\t\t\t\tresult = ((dependency === commonJsRequireModule) ? createRequire(module) :\n\t\t\t\t\t\t\t\t((dependency === commonJsExportsModule) ? module.cjs.exports :\n\t\t\t\t\t\t\t\t\t((dependency === commonJsModuleModule) ? module.cjs :\n\t\t\t\t\t\t\t\t\t\texecuteModule(dependency))));\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t});\n\n\t\t\tif (result === ABORT_EXECUTION) {\n\t\t\t\tmodule.executed = false;\n\t\t\t\thas('loader-debug-circular-dependencies') && circularTrace.pop();\n\t\t\t\treturn ABORT_EXECUTION;\n\t\t\t}\n\n\t\t\tconst factory: DojoLoader.Factory = module.def;\n\t\t\tresult = typeof factory === 'function' ? factory.apply(null, executedDependencies) : factory;\n\n\t\t\t// TODO: But of course, module.cjs always exists.\n\t\t\t// Assign the new module.result to result so plugins can use exports\n\t\t\t// to define their interface; the plugin checks below use result\n\t\t\tresult = module.result = result === undefined && module.cjs ? module.cjs.exports : result;\n\t\t\tmodule.executed = true;\n\t\t\texecutedSomething = true;\n\n\t\t\t// delete references to synthetic modules\n\t\t\tif (module.gc) {\n\t\t\t\tmodules[module.mid] = undefined;\n\t\t\t}\n\n\t\t\t// if result defines load, just assume it's a plugin; harmless if the assumption is wrong\n\t\t\tresult && result.load && [ 'normalize', 'load' ].forEach(function (key: string): void {\n\t\t\t\t(<any> module)[key] = (<any> result)[key];\n\t\t\t});\n\n\t\t\t// for plugins, resolve the loadQ\n\t\t\tforEach(module.loadQ || [], function (pseudoPluginResource: DojoLoader.Module): void {\n\t\t\t\t// manufacture and insert the real module in modules\n\t\t\t\tconst pluginResourceId: string = resolvePluginResourceId(module, pseudoPluginResource.prid,\n\t\t\t\t\tpseudoPluginResource.req);\n\t\t\t\tconst moduleId: string = (module.mid + '!' + pluginResourceId);\n\t\t\t\tconst pluginResource: DojoLoader.Module =\n\t\t\t\t\t<DojoLoader.Module> mix(mix({}, pseudoPluginResource), { mid: moduleId, prid: pluginResourceId });\n\n\t\t\t\tif (!modules[moduleId]) {\n\t\t\t\t\t// create a new (the real) plugin resource and inject it normally now that the plugin is on board\n\t\t\t\t\tinjectPlugin((modules[moduleId] = pluginResource));\n\t\t\t\t} // else this was a duplicate request for the same (plugin, rid)\n\n\t\t\t\t// pluginResource is really just a placeholder with the wrong moduleId (because we couldn't calculate it\n\t\t\t\t// until the plugin was on board) fix() replaces the pseudo module in a resolved dependencies array with the\n\t\t\t\t// real module lastly, mark the pseudo module as arrived and delete it from modules\n\t\t\t\tif (pseudoPluginResource && pseudoPluginResource.fix) {\n\t\t\t\t\tpseudoPluginResource.fix(<any> modules[moduleId]);\n\t\t\t\t}\n\t\t\t\t--waitingCount;\n\t\t\t\tmodules[pseudoPluginResource.mid] = undefined;\n\t\t\t});\n\t\t\tmodule.loadQ = undefined;\n\n\t\t\thas('loader-debug-circular-dependencies') && circularTrace.pop();\n\t\t}\n\n\t\t// at this point the module is guaranteed fully executed\n\t\treturn module.result;\n\t}\n\n\t// TODO: Figure out what proc actually is\n\tfunction guardCheckComplete(callback: Function): void {\n\t\t++checkCompleteGuard;\n\t\tcallback();\n\t\t--checkCompleteGuard;\n\t}\n\n\tfunction checkComplete(): void {\n\t\t// keep going through the executionQueue as long as at least one factory is executed\n\t\t// plugins, recursion, cached modules all make for many execution path possibilities\n\t\t!checkCompleteGuard && guardCheckComplete(function (): void {\n\t\t\tfor (let module: DojoLoader.Module, i = 0; i < executionQueue.length; ) {\n\t\t\t\tmodule = executionQueue[i];\n\t\t\t\tif (module.executed === true) {\n\t\t\t\t\texecutionQueue.splice(i, 1);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\texecutedSomething = false;\n\t\t\t\t\texecuteModule(module);\n\t\t\t\t\tif (executedSomething) {\n\t\t\t\t\t\t// something was executed; this indicates the executionQueue was modified, maybe a\n\t\t\t\t\t\t// lot (for example a later module causes an earlier module to execute)\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// nothing happened; check the next module in the exec queue\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction injectPlugin(module: DojoLoader.Module): void {\n\t\t// injects the plugin module given by module; may have to inject the plugin itself\n\t\tconst plugin: DojoLoader.Module | undefined = module.plugin;\n\t\tconst onLoad = function (def: any): void {\n\t\t\t\tmodule.result = def;\n\t\t\t\t--waitingCount;\n\t\t\t\tmodule.executed = true;\n\t\t\t\tcheckComplete();\n\t\t\t};\n\n\t\tif (plugin && plugin.load) {\n\t\t\tplugin.load(module.prid, module.req, onLoad, config);\n\t\t}\n\t\telse if (plugin && plugin.loadQ) {\n\t\t\tplugin.loadQ.push(module);\n\t\t}\n\t\telse if (plugin) {\n\t\t\t// the unshift instead of push is important: we don't want plugins to execute as\n\t\t\t// dependencies of some other module because this may cause circles when the plugin\n\t\t\t// loadQ is run; also, generally, we want plugins to run early since they may load\n\t\t\t// several other modules and therefore can potentially unblock many modules\n\t\t\tplugin.loadQ = [ module ];\n\t\t\texecutionQueue.unshift(plugin);\n\t\t\tinjectModule(module, plugin);\n\t\t}\n\t}\n\n\tfunction injectModule(parent?: DojoLoader.Module, module?: DojoLoader.Module): void {\n\t\t// TODO: This is for debugging, we should bracket it\n\t\tif (!module) {\n\t\t\tmodule = parent;\n\t\t\tparent = undefined;\n\t\t}\n\n\t\tif (module && module.plugin) {\n\t\t\tinjectPlugin(module);\n\t\t}\n\t\telse if (module && !module.injected) {\n\t\t\tlet cached: DojoLoader.Factory;\n\t\t\tconst onLoadCallback = function (node?: HTMLScriptElement): void {\n\t\t\t\t// DojoLoader.moduleDefinitionArguments is an array of [dependencies, factory]\n\t\t\t\tconsumePendingCacheInsert(module);\n\n\t\t\t\tlet moduleDefArgs: string[] = [];\n\t\t\t\tlet moduleDefFactory: DojoLoader.Factory | undefined = undefined;\n\n\t\t\t\t// non-amd module\n\t\t\t\tif (moduleDefinitionArguments) {\n\t\t\t\t\tmoduleDefArgs = moduleDefinitionArguments[0];\n\t\t\t\t\tmoduleDefFactory = moduleDefinitionArguments[1];\n\t\t\t\t}\n\n\t\t\t\tdefineModule(module, moduleDefArgs, moduleDefFactory);\n\t\t\t\tmoduleDefinitionArguments = undefined;\n\n\t\t\t\tguardCheckComplete(function (): void {\n\t\t\t\t\tforEach((module && module.deps) || [], injectModule.bind(null, module));\n\t\t\t\t});\n\t\t\t\tcheckComplete();\n\t\t\t};\n\n\t\t\t++waitingCount;\n\t\t\tmodule.injected = true;\n\t\t\tif ((cached = cache[module.mid])) {\n\t\t\t\ttry {\n\t\t\t\t\tcached();\n\t\t\t\t\tonLoadCallback();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcatch (error) {\n\t\t\t\t\t// If a cache load fails, retrieve using injectUrl\n\t\t\t\t\t// TODO: report error, 'cachedThrew', [ error, module ]\n\t\t\t\t}\n\t\t\t}\n\t\t\tinjectUrl(module.url, onLoadCallback, module, parent);\n\t\t}\n\t}\n\n\tfunction resolveDependencies(dependencies: string[], module: DojoLoader.Module, referenceModule?: DojoLoader.Module): DojoLoader.Module[] {\n\t\t// resolve dependencies with respect to this module\n\t\treturn dependencies.map(function (dependency: string, i: number): DojoLoader.Module {\n\t\t\tconst result: DojoLoader.Module = getModule(dependency, referenceModule);\n\t\t\tif (result.fix) {\n\t\t\t\tresult.fix = function (m: DojoLoader.Module): void {\n\t\t\t\t\tmodule.deps[i] = m;\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn result;\n\t\t});\n\t}\n\n\tfunction defineModule(module: DojoLoader.Module | undefined, dependencies: string[], factory?: DojoLoader.Factory): DojoLoader.Module | undefined {\n\t\t--waitingCount;\n\t\treturn initializeModule(module, dependencies, factory);\n\t}\n\n\tfunction initializeModule(module: DojoLoader.Module | undefined, dependencies: string[], factory?: DojoLoader.Factory): DojoLoader.Module | undefined {\n\t\tconst moduleToInitialize = module;\n\t\tlet initializedModule: DojoLoader.Module | undefined = undefined;\n\n\t\tif (moduleToInitialize) {\n\t\t\tinitializedModule = <DojoLoader.Module> mix(moduleToInitialize, {\n\t\t\t\tdef: factory,\n\t\t\t\tdeps: resolveDependencies(dependencies, moduleToInitialize, moduleToInitialize),\n\t\t\t\tcjs: {\n\t\t\t\t\tid: moduleToInitialize.mid,\n\t\t\t\t\turi: moduleToInitialize.url,\n\t\t\t\t\texports: (moduleToInitialize.result = {}),\n\t\t\t\t\tsetExports: function (exports: any): void {\n\t\t\t\t\t\tmoduleToInitialize.cjs.exports = exports;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn initializedModule;\n\t}\n\n\thas.add('function-bind', Boolean(Function.prototype.bind));\n\tif (!has('function-bind')) {\n\t\tinjectModule.bind = function (thisArg: any): typeof injectModule {\n\t\t\tconst slice = Array.prototype.slice;\n\t\t\tconst args: any[] = slice.call(arguments, 1);\n\n\t\t\treturn function (): void {\n\t\t\t\treturn injectModule.apply(thisArg, args.concat(slice.call(arguments, 0)));\n\t\t\t};\n\t\t};\n\t}\n\n\tlet globalObjectGlobals = function (require: DojoLoader.Require, define: DojoLoader.Define): void {\n\t\tglobalObject.require = require;\n\t\tglobalObject.define = define;\n\t};\n\n\tif (has('host-node')) {\n\t\tloadNodeModule = (moduleId: string, parent?: DojoLoader.Module): any => {\n\t\t\tlet module: any = require('module');\n\t\t\tlet result: any;\n\n\t\t\tif (module._findPath && module._nodeModulePaths) {\n\t\t\t\tlet localModulePath = module._findPath(moduleId, module._nodeModulePaths(toUrl('.', parent)));\n\n\t\t\t\tif (localModulePath !== false) {\n\t\t\t\t\tmoduleId = localModulePath;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Some modules attempt to detect an AMD loader by looking for global AMD `define`. This causes issues\n\t\t\t// when other CommonJS modules attempt to load them via the standard Node.js `require`, so hide it\n\t\t\t// during the load\n\t\t\tglobalObject.define = undefined;\n\n\t\t\ttry {\n\t\t\t\tif (requireModule && requireModule.nodeRequire) {\n\t\t\t\t\tresult = requireModule.nodeRequire(moduleId);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (error) {\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tglobalObject.define = define;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t};\n\n\t\tconst vm: any = require('vm');\n\t\tconst fs: any = require('fs');\n\n\t\t// retain the ability to get node's require\n\t\trequireModule.nodeRequire = require;\n\t\tinjectUrl = function (url: string, callback: (node?: HTMLScriptElement) => void,\n\t\t\t\t\t\t\tmodule: DojoLoader.Module, parent?: DojoLoader.Module): void {\n\t\t\tfs.readFile(url, 'utf8', function (error: Error, data: string): void {\n\t\t\t\tfunction loadCallback () {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet result = loadNodeModule(module.mid, parent);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (error) {\n\t\t\t\t\t\treportModuleLoadError(parent, module, url, error.message);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (error) {\n\t\t\t\t\tmoduleDefinitionArguments = [ [], loadCallback ];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// global `module` variable needs to be shadowed for UMD modules that are loaded in an Electron\n\t\t\t\t\t// webview; in Node.js the `module` variable does not exist when using `vm.runInThisContext`,\n\t\t\t\t\t// but in Electron it exists in the webview when Node.js integration is enabled which causes loaded\n\t\t\t\t\t// modules to register with Node.js and break the loader\n\t\t\t\t\tlet oldModule = globalObject.module;\n\t\t\t\t\tglobalObject.module = undefined;\n\t\t\t\t\ttry {\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * Using an `object` as a second argument causes Instabul\n\t\t\t\t\t\t * issues and then thinks the file should not be instrumented\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * See: dojo/loader#57\n\t\t\t\t\t\t */\n\t\t\t\t\t\tvm.runInThisContext(data, url);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (error) {\n\t\t\t\t\t\treportModuleLoadError(parent, module, url, error.message);\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tglobalObject.module = oldModule;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcallback();\n\t\t\t});\n\t\t};\n\n\t\tsetGlobals = function (require: DojoLoader.RootRequire, define: DojoLoader.Define): void {\n\t\t\tmodule.exports = globalObject.require = require;\n\t\t\tglobalObject.define = define;\n\t\t};\n\t}\n\telse if (has('host-browser')) {\n\t\tinjectUrl = function (url: string, callback: (node?: HTMLScriptElement) => void, module: DojoLoader.Module,\n\t\t\t\t\t\t\tparent?: DojoLoader.Module): void {\n\t\t\t// insert a script element to the insert-point element with src=url;\n\t\t\t// apply callback upon detecting the script has loaded.\n\t\t\tconst node: HTMLScriptElement = document.createElement('script');\n\t\t\tconst handler: EventListener = function (event: Event): void {\n\t\t\t\tdocument.head.removeChild(node);\n\n\t\t\t\tif (event.type === 'load') {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treportModuleLoadError(parent, module, url);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tnode.addEventListener('load', handler, false);\n\t\t\tnode.addEventListener('error', handler, false);\n\n\t\t\tif (config.crossOrigin !== false) {\n\t\t\t\t(<any> node).crossOrigin = config.crossOrigin;\n\t\t\t}\n\n\t\t\tnode.charset = 'utf-8';\n\t\t\tnode.src = url;\n\t\t\tdocument.head.appendChild(node);\n\t\t};\n\n\t\tsetGlobals = globalObjectGlobals;\n\t}\n\telse if (has('host-nashorn')) {\n\t\tinjectUrl = function (url: string, callback: (node?: HTMLScriptElement) => void, module: DojoLoader.Module,\n\t\t\tparent?: DojoLoader.Module): void {\n\n\t\t\tload(url);\n\t\t\tcallback();\n\t\t};\n\n\t\tsetGlobals = globalObjectGlobals;\n\t}\n\telse {\n\t\tthrow new Error('Unsupported platform');\n\t}\n\n\thas.add('loader-debug-internals', true);\n\tif (has('loader-debug-internals')) {\n\t\trequireModule.inspect = function (name: string): any {\n\t\t\t/* tslint:disable:no-eval */\n\t\t\t// TODO: Should this use console.log so people do not get any bright ideas about using this in apps?\n\t\t\treturn eval(name);\n\t\t\t/* tslint:enable:no-eval */\n\t\t};\n\t}\n\n\thas.add('loader-undef', true);\n\tif (has('loader-undef')) {\n\t\trequireModule.undef = function (id: string, recursive?: boolean): void {\n\t\t\tconst module: Module | undefined = modules[id];\n\t\t\tconst undefDeps = function (mod: Module): void {\n\t\t\t\tif (mod.deps) {\n\t\t\t\t\tforEach(mod.deps, undefDeps);\n\t\t\t\t}\n\t\t\t\tmodules[mod.mid] = undefined;\n\t\t\t};\n\t\t\tif (module) {\n\t\t\t\tif (recursive && module.deps) {\n\t\t\t\t\tforEach(module.deps, undefDeps);\n\t\t\t\t}\n\t\t\t\tmodules[id] = undefined;\n\t\t\t}\n\t\t};\n\t}\n\n\tmix(requireModule, {\n\t\ttoAbsMid: toAbsMid,\n\t\ttoUrl: toUrl,\n\n\t\tcache: function (cache: DojoLoader.ObjectMap): void {\n\t\t\tconsumePendingCacheInsert();\n\t\t\tpendingCacheInsert = cache;\n\t\t}\n\t});\n\n\tObject.defineProperty(requireModule, 'baseUrl', {\n\t\tget: function (): string | undefined {\n\t\t\treturn config.baseUrl;\n\t\t},\n\t\tenumerable: true\n\t});\n\n\thas.add('loader-cjs-wrapping', true);\n\n\tlet comments: RegExp;\n\tlet requireCall: RegExp;\n\n\tif (has('loader-cjs-wrapping')) {\n\t\tcomments = /\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*$/mg;\n\t\trequireCall = /require\\s*\\(\\s*([\"'])(.*?[^\\\\])\\1\\s*\\)/g;\n\t}\n\n\thas.add('loader-explicit-mid', true);\n\n\t/**\n\t * @param deps //(array of commonjs.moduleId, optional)\n\t * @param factory //(any)\n\t */\n\tlet define: DojoLoader.Define = <DojoLoader.Define> mix(function (dependencies: string[], factory: DojoLoader.Factory): void {\n\t\tlet originalFactory: any;\n\t\tif (has('loader-explicit-mid') && arguments.length > 1 && typeof dependencies === 'string') {\n\t\t\tlet id: string = <any> dependencies;\n\t\t\tif (arguments.length === 3) {\n\t\t\t\tdependencies = <any> factory;\n\t\t\t\tfactory = arguments[2];\n\t\t\t} else {\n\t\t\t\tdependencies = [];\n\t\t\t}\n\n\t\t\t// Some modules in the wild have an explicit module ID that is null; ignore the module ID in this case and\n\t\t\t// register normally using the request module ID\n\t\t\tif (id != null) {\n\t\t\t\tlet module: DojoLoader.Module = getModule(id);\n\t\t\t\tif (factory) {\n\t\t\t\t\toriginalFactory = factory;\n\t\t\t\t\tfactory = function () {\n\t\t\t\t\t\tmodule.executed = true;\n\t\t\t\t\t\treturn (module.result = originalFactory.apply ?\n\t\t\t\t\t\t\toriginalFactory.apply(null, arguments) : originalFactory);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tmodule.injected = true;\n\t\t\t\tdefineModule(module, dependencies, factory);\n\t\t\t\tguardCheckComplete(function (): void {\n\t\t\t\t\tforEach(module.deps, injectModule.bind(null, module));\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (arguments.length === 1) {\n\t\t\tif (has('loader-cjs-wrapping') && typeof dependencies === 'function') {\n\t\t\t\toriginalFactory = <any> dependencies;\n\t\t\t\tdependencies = [ 'require', 'exports', 'module' ];\n\n\t\t\t\t// Scan factory for require() calls and add them to the\n\t\t\t\t// list of dependencies\n\t\t\t\toriginalFactory.toString()\n\t\t\t\t\t.replace(comments, '')\n\t\t\t\t\t.replace(requireCall, function (): string {\n\t\t\t\t\t\tdependencies.push(/* mid */ arguments[2]);\n\t\t\t\t\t\treturn arguments[0];\n\t\t\t\t\t});\n\t\t\t\tfactory = function (require, exports, module): any {\n\t\t\t\t\tconst originalModuleId = module.id;\n\t\t\t\t\tlet result: any = originalFactory.apply(null, arguments);\n\t\t\t\t\tif (originalModuleId !== module.id) {\n\t\t\t\t\t\tconst newModule: DojoLoader.Module = getModule(module.id);\n\t\t\t\t\t\tdefineModule(newModule, dependencies, undefined);\n\t\t\t\t\t\tnewModule.injected = true;\n\t\t\t\t\t\tnewModule.executed = true;\n\t\t\t\t\t\tnewModule.result = module.exports = result || module.exports;\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\t\t\t}\n\t\t\telse if (/* define(value) */ !Array.isArray(dependencies)) {\n\t\t\t\tconst value: any = dependencies;\n\t\t\t\tdependencies = [];\n\t\t\t\tfactory = function (): any {\n\t\t\t\t\treturn value;\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tmoduleDefinitionArguments = [ dependencies, factory ];\n\t}, {\n\t\tamd: { vendor: 'dojotoolkit.org' }\n\t});\n\n\tsetGlobals(requireModule, define);\n\tif (has('host-nashorn') && args && args[0]) {\n\t\tload(args[0]);\n\t}\n})((typeof Packages !== 'undefined' ? Array.prototype.slice.call(arguments, 0) : []));\n"]}