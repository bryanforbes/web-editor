var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "@dojo/core/async/Task", "@dojo/core/Evented", "@dojo/core/on", "@dojo/core/UrlSearchParams", "@dojo/shim/array", "@dojo/shim/Promise", "@dojo/shim/WeakMap", "./lib/path"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Task_1 = require("@dojo/core/async/Task");
    var Evented_1 = require("@dojo/core/Evented");
    var on_1 = require("@dojo/core/on");
    var UrlSearchParams_1 = require("@dojo/core/UrlSearchParams");
    var array_1 = require("@dojo/shim/array");
    var Promise_1 = require("@dojo/shim/Promise");
    var WeakMap_1 = require("@dojo/shim/WeakMap");
    var path_1 = require("./lib/path");
    var parentMap = new WeakMap_1.default();
    /**
     * Whether the route has been appended to another route or router.
     */
    function hasBeenAppended(route) {
        return parentMap.has(route) || route.parent !== undefined;
    }
    exports.hasBeenAppended = hasBeenAppended;
    /**
     * Finds the router whose route hierarchy the route has been appended to.
     *
     * Throws if the route was not appended to any router.
     */
    function findRouter(route) {
        while (route.parent) {
            route = route.parent;
        }
        var router = parentMap.get(route);
        if (!router) {
            throw new Error('Cannot generate link for route that is not in the hierarchy');
        }
        else {
            return router;
        }
    }
    exports.findRouter = findRouter;
    // istanbul ignore next
    var noop = function () {
    };
    function createDeferral() {
        // Use noop since TypeScript doesn't know we're assigning cancel and resume in the promise executor.
        var cancel = noop;
        var resume = noop;
        var promise = new Promise_1.default(function (resolve, reject) {
            cancel = reject;
            // Wrap resolve to avoid resume being called with a thenable if type checking is not used.
            resume = function () { return resolve(); };
        });
        return { cancel: cancel, promise: promise, resume: resume };
    }
    function reportError(router, context, path, error) {
        router.emit({
            context: context,
            error: error,
            path: path,
            target: router,
            type: 'error'
        });
    }
    function catchRejection(router, context, path, thenable) {
        if (thenable) {
            Promise_1.default.resolve(thenable).catch(function (error) {
                reportError(router, context, path, error);
            });
        }
    }
    var Router = (function (_super) {
        __extends(Router, _super);
        function Router(options) {
            if (options === void 0) { options = {}; }
            var _this = this;
            var context = options.context, fallback = options.fallback, history = options.history;
            _this = _super.call(this, {}) || this;
            var contextFactory;
            if (typeof context === 'function') {
                contextFactory = context;
            }
            else if (typeof context === 'undefined') {
                contextFactory = function () {
                    return {};
                };
            }
            else {
                // Assign to a constant since the context variable may be changed after the function is defined,
                // which would violate its typing.
                var sharedContext_1 = context;
                contextFactory = function () { return sharedContext_1; };
            }
            if (history) {
                _this.own(history);
            }
            _this._contextFactory = contextFactory;
            _this._currentSelection = [];
            _this._dispatchFromStart = false;
            _this._fallback = fallback;
            _this._history = history;
            _this._routes = [];
            _this._started = false;
            return _this;
        }
        Router.prototype.append = function (add) {
            var _this = this;
            var append = function (route) {
                if (hasBeenAppended(route)) {
                    throw new Error('Cannot append route that has already been appended');
                }
                _this._routes.push(route);
                parentMap.set(route, _this);
            };
            if (Array.isArray(add)) {
                for (var _i = 0, add_1 = add; _i < add_1.length; _i++) {
                    var route = add_1[_i];
                    append(route);
                }
            }
            else {
                append(add);
            }
        };
        Router.prototype.dispatch = function (context, path) {
            var _this = this;
            // Reset, any further calls can't have come from start(). This is necessary since the navstart listeners
            // may call dispatch() themselves.
            var dispatchFromStart = this._dispatchFromStart;
            this._dispatchFromStart = false;
            var canceled = false;
            var cancel = function () {
                canceled = true;
            };
            var deferrals = [];
            this.emit({
                cancel: cancel,
                defer: function () {
                    var _a = createDeferral(), cancel = _a.cancel, promise = _a.promise, resume = _a.resume;
                    deferrals.push(promise);
                    return { cancel: cancel, resume: resume };
                },
                path: path,
                target: this,
                type: 'navstart'
            });
            // Synchronous cancelation.
            if (canceled) {
                return Task_1.default.resolve({ success: false });
            }
            var _a = path_1.parse(path), searchParams = _a.searchParams, segments = _a.segments, trailingSlash = _a.trailingSlash;
            return new Task_1.default(function (resolve, reject) {
                // *Always* start dispatching in a future turn, even if there were no deferrals.
                Promise_1.default.all(deferrals).then(function () {
                    // The cancel() function used in the NavigationStartEvent is reused as the Task canceler.
                    // Strictly speaking any navstart listener can cancel the dispatch asynchronously, as long as it
                    // manages to do so before this turn.
                    if (canceled) {
                        return { success: false };
                    }
                    var redirect;
                    var dispatched = _this._routes.some(function (route) {
                        var result = route.select(context, segments, trailingSlash, searchParams);
                        if (typeof result === 'string') {
                            redirect = result;
                            return true;
                        }
                        if (result.length === 0) {
                            return false;
                        }
                        // Update the selected routes after selecting new routes, but before invoking the handlers.
                        // This means the original value is available to guard() and params() functions, and the
                        // new value when the newly selected routes are executed.
                        //
                        // Reset selected routes if not dispatched from start().
                        _this._currentSelection = dispatchFromStart ? result : [];
                        for (var _i = 0, result_1 = result; _i < result_1.length; _i++) {
                            var _a = result_1[_i], handler = _a.handler, params = _a.params;
                            catchRejection(_this, context, path, handler({ context: context, params: params }));
                        }
                        return true;
                    });
                    // Reset the selected routes if the dispatch was unsuccessful, or if a redirect was requested.
                    if (!dispatched || redirect !== undefined) {
                        _this._currentSelection = [];
                    }
                    if (!dispatched && _this._fallback) {
                        catchRejection(_this, context, path, _this._fallback({ context: context, params: {} }));
                        return { success: false };
                    }
                    var result = { success: dispatched };
                    if (redirect !== undefined) {
                        result.redirect = redirect;
                    }
                    return result;
                }, 
                // When deferrals are canceled their corresponding promise is rejected. Ensure the task resolves
                // with `false` instead of being rejected too.
                function () {
                    return { success: false };
                }).then(resolve, function (error) {
                    reportError(_this, context, path, error);
                    reject(error);
                });
            }, cancel);
        };
        Router.prototype.link = function (route, params) {
            var _this = this;
            if (params === void 0) { params = {}; }
            var hierarchy = [route];
            for (var parent_1 = route.parent; parent_1 !== undefined; parent_1 = parent_1.parent) {
                hierarchy.unshift(parent_1);
            }
            if (!array_1.includes(this._routes, hierarchy[0])) {
                throw new Error('Cannot generate link for route that is not in the hierarchy');
            }
            var addLeadingSlash = hierarchy[0].path.leadingSlash;
            var addTrailingSlash = false;
            var segments = [];
            var searchParams = new UrlSearchParams_1.default();
            hierarchy
                .map(function (route, index) {
                var path = route.path;
                var currentPathValues;
                var currentSearchParams;
                var selection = _this._currentSelection[index];
                if (selection && selection.route === route) {
                    currentPathValues = selection.rawPathValues;
                    currentSearchParams = selection.rawSearchParams;
                }
                return { currentPathValues: currentPathValues, currentSearchParams: currentSearchParams, path: path };
            })
                .forEach(function (_a) {
                var currentPathValues = _a.currentPathValues, currentSearchParams = _a.currentSearchParams, path = _a.path;
                var expectedSegments = path.expectedSegments, searchParameters = path.searchParameters, trailingSlash = path.trailingSlash;
                addTrailingSlash = trailingSlash;
                var namedOffset = 0;
                for (var _i = 0, expectedSegments_1 = expectedSegments; _i < expectedSegments_1.length; _i++) {
                    var segment = expectedSegments_1[_i];
                    if (path_1.isNamedSegment(segment)) {
                        var value = params[segment.name];
                        if (typeof value === 'string') {
                            segments.push(value);
                        }
                        else if (Array.isArray(value)) {
                            if (value.length === 1) {
                                segments.push(value[0]);
                            }
                            else {
                                throw new TypeError("Cannot generate link, multiple values for parameter '" + segment.name + "'");
                            }
                        }
                        else if (currentPathValues) {
                            segments.push(currentPathValues[namedOffset]);
                        }
                        else {
                            throw new Error("Cannot generate link, missing parameter '" + segment.name + "'");
                        }
                        namedOffset++;
                    }
                    else {
                        segments.push(segment.literal);
                    }
                }
                for (var _b = 0, searchParameters_1 = searchParameters; _b < searchParameters_1.length; _b++) {
                    var key = searchParameters_1[_b];
                    // Don't repeat the search parameter if a previous route in the hierarchy has already appended
                    // it.
                    if (searchParams.has(key)) {
                        continue;
                    }
                    var value = params[key];
                    if (typeof value === 'string') {
                        searchParams.append(key, value);
                    }
                    else if (Array.isArray(value)) {
                        for (var _c = 0, value_1 = value; _c < value_1.length; _c++) {
                            var item = value_1[_c];
                            searchParams.append(key, item);
                        }
                    }
                    else if (currentSearchParams) {
                        for (var _d = 0, _e = currentSearchParams[key]; _d < _e.length; _d++) {
                            var item = _e[_d];
                            searchParams.append(key, item);
                        }
                    }
                    else {
                        throw new Error("Cannot generate link, missing search parameter '" + key + "'");
                    }
                }
            });
            var pathname = segments.join('/');
            if (addLeadingSlash) {
                pathname = '/' + pathname;
            }
            if (addTrailingSlash) {
                pathname += '/';
            }
            if (this._history) {
                pathname = this._history.prefix(pathname);
            }
            var search = searchParams.toString();
            var path = search ? pathname + "?" + search : pathname;
            return path;
        };
        Router.prototype.replacePath = function (path) {
            if (!this._history) {
                throw new Error('Cannot replace path, router was created without a history manager');
            }
            this._history.replace(path);
        };
        Router.prototype.setPath = function (path) {
            if (!this._history) {
                throw new Error('Cannot set path, router was created without a history manager');
            }
            this._history.set(path);
        };
        Router.prototype.start = function (startOptions) {
            var _this = this;
            if (startOptions === void 0) { startOptions = { dispatchCurrent: true }; }
            var dispatchCurrent = startOptions.dispatchCurrent;
            if (this._started) {
                throw new Error('start can only be called once');
            }
            this._started = true;
            if (!this._history) {
                return {
                    pause: function () {
                    },
                    resume: function () {
                    },
                    destroy: function () {
                    }
                };
            }
            var lastDispatch;
            var redirectCount = 0;
            var redirecting = false;
            var dispatch = function (path) {
                if (lastDispatch) {
                    lastDispatch.cancel();
                }
                // Reset redirect count if the dispatch was triggered by a non-redirect history change. This allows
                // a route's exec / fallback / index handler to change the history, setting off a new flurry of
                // redirects, without being encumbered by the number of redirects that led to that route being selected.
                if (!redirecting) {
                    redirectCount = 0;
                }
                // Signal to dispatch() that it was called from here.
                _this._dispatchFromStart = true;
                var context = _this._contextFactory();
                lastDispatch = _this.dispatch(context, path).then(function (dispatchResult) {
                    var _a = dispatchResult || { success: false }, success = _a.success, _b = _a.redirect, redirect = _b === void 0 ? undefined : _b;
                    if (success && redirect !== undefined) {
                        redirectCount++;
                        if (redirectCount > 20) {
                            var error = new Error('More than 20 redirects, giving up');
                            reportError(_this, context, path, error);
                            throw error;
                        }
                        redirecting = true;
                        // The history manager MUST emit the change event synchronously.
                        _this._history.replace(redirect);
                        redirecting = false;
                    }
                    return dispatchResult;
                });
            };
            var listener = on_1.pausable(this._history, 'change', function (event) {
                dispatch(event.value);
            });
            this.own(listener);
            if (dispatchCurrent) {
                dispatch(this._history.current);
            }
            return listener;
        };
        return Router;
    }(Evented_1.default));
    exports.Router = Router;
    exports.default = Router;
});
//# sourceMappingURL=Router.js.map