import Task from '@dojo/core/async/Task';
import Evented, { BaseEventedEvents } from '@dojo/core/Evented';
import { Hash } from '@dojo/core/interfaces';
import { PausableHandle } from '@dojo/core/on';
import { EventedOptions, EventedListener } from '@dojo/interfaces/bases';
import { EventTargettedObject, EventErrorObject, Handle } from '@dojo/interfaces/core';
import { Thenable } from '@dojo/shim/interfaces';
import { History } from './history/interfaces';
import { Context, Parameters, Request } from './interfaces';
import { Route } from './Route';
/**
 * An object to resume or cancel router dispatch.
 */
export interface DispatchDeferral {
    /**
     * Call to prevent a path from being dispatched.
     */
    cancel(): void;
    /**
     * Call to resume a path being dispatched.
     */
    resume(): void;
}
/**
 * Event object that is emitted for the 'navstart' event.
 */
export interface NavigationStartEvent extends EventTargettedObject<Router<Context>> {
    /**
     * The path that has been navigated to.
     */
    path: string;
    /**
     * Call to prevent the path to be dispatched.
     */
    cancel(): void;
    /**
     * Call to defer dispatching of the path
     * @return an object which allows the caller to resume or cancel dispatch.
     */
    defer(): DispatchDeferral;
}
/**
 * Event object that is emitted for the 'error' event.
 */
export interface ErrorEvent<C extends Context> extends EventErrorObject<Router<C>> {
    /**
     * The context that was being dispatched when the error occurred.
     */
    context: C;
    /**
     * The path that was being dispatched when the error occurred.
     */
    path: string;
}
/**
 * Describes the result of a dispatch.
 */
export interface DispatchResult {
    /**
     * Whether a route requested a redirect to a different path.
     */
    redirect?: string;
    /**
     * False if dispatch was canceled (via the navstart event) or if no routes could be selected. True otherwise.
     */
    success: boolean;
}
export declare type LinkParams = Hash<string | string[] | undefined>;
export interface RouterEvents<C extends Context> extends BaseEventedEvents {
    /**
     * Event emitted when dispatch is called, but before routes are selected.
     */
    (type: 'navstart', listener: EventedListener<Router<C>, NavigationStartEvent>): Handle;
    /**
     * Event emitted when errors occur during dispatch.
     *
     * Certain errors may reject the task returned when dispatching, but this task is not always accessible and may
     * hide errors if it's canceled.
     */
    (type: 'error', listener: EventedListener<Router<C>, ErrorEvent<C>>): Handle;
}
/**
 * The options for the router.
 */
export interface RouterOptions<C extends Context> extends EventedOptions {
    /**
     * A Context object to be used for all requests, or a function that provides such an object, called for each
     * dispatch.
     */
    context?: C | (() => C);
    /**
     * A handler called when no routes match the dispatch path.
     * @param request An object whose `context` property contains the dispatch context. No extracted parameters
     *   are available.
     */
    fallback?: (request: Request<C, Parameters>) => void | Thenable<any>;
    /**
     * The history manager. Routes will be dispatched in response to change events emitted by the manager.
     */
    history?: History;
}
/**
 * The options for the router's start() method.
 */
export interface StartOptions {
    /**
     * Whether to immediately dispatch with the history's current value.
     */
    dispatchCurrent: boolean;
}
/**
 * Whether the route has been appended to another route or router.
 */
export declare function hasBeenAppended(route: Route<Context, Parameters>): boolean;
/**
 * Finds the router whose route hierarchy the route has been appended to.
 *
 * Throws if the route was not appended to any router.
 */
export declare function findRouter(route: Route<Context, Parameters>): Router<Context>;
export declare class Router<C extends Context> extends Evented {
    private _contextFactory;
    private _currentSelection;
    private _dispatchFromStart;
    private _fallback?;
    private _history?;
    private _routes;
    private _started?;
    on: RouterEvents<C>;
    constructor(options?: RouterOptions<C>);
    append(add: Route<Context, Parameters> | Route<Context, Parameters>[]): void;
    dispatch(context: Context, path: string): Task<DispatchResult>;
    link(route: Route<Context, Parameters>, params?: LinkParams): string;
    replacePath(path: string): void;
    setPath(path: string): void;
    start(startOptions?: StartOptions): PausableHandle;
}
export default Router;
