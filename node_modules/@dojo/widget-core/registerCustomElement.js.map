{"version":3,"file":"registerCustomElement.js","sourceRoot":"","sources":["registerCustomElement.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;IAAA,mDAAsG;IAetG;;;;;;OAMG;IACH,+BAAsC,iBAAiD;QACtF,IAAM,UAAU,GAAG,iBAAiB,EAAE,CAAC;QAEvC,cAAc,CAAC,MAAM,CAAC,UAAU,CAAC,OAAO;YAAgB,2BAAW;YAKlE;gBAAA,YACC,iBAAO,SAGP;gBARO,iBAAW,GAAG,KAAK,CAAC;gBAO3B,KAAI,CAAC,SAAS,GAAG,kCAAiB,CAAC,KAAI,CAAC,CAAC;;YAC1C,CAAC;YAED,mCAAiB,GAAjB;gBACC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC;oBACvB,IAAI,CAAC,SAAS,EAAE,CAAC;oBACjB,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;gBACzB,CAAC;YACF,CAAC;YAED,0CAAwB,GAAxB,UAAyB,IAAY,EAAE,QAAuB,EAAE,QAAuB;gBACtF,uCAAsB,CAAC,IAAI,EAAE,IAAI,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC;YACxD,CAAC;YAED,mCAAiB,GAAjB;gBACC,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC;YAC7B,CAAC;YAED,mCAAiB,GAAjB,UAAkB,MAAuB;gBACxC,IAAI,CAAC,eAAe,GAAG,MAAM,CAAC;YAC/B,CAAC;YAED,sCAAoB,GAApB;gBACC,MAAM,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC,iBAAiB,CAAC;YAC/C,CAAC;YAED,+BAAa,GAAb;gBACC,MAAM,CAAC,UAAU,CAAC;YACnB,CAAC;YAED,sBAAW,6BAAkB;qBAA7B;oBACC,MAAM,CAAC,CAAC,UAAU,CAAC,UAAU,IAAI,EAAE,CAAC,CAAC,GAAG,CAAC,UAAA,SAAS,IAAI,OAAA,SAAS,CAAC,aAAa,EAAvB,CAAuB,CAAC,CAAC;gBAChF,CAAC;;;eAAA;YACF,cAAC;QAAD,CAAC,AAzCyC,CAAc,WAAW,GAyCjE,CAAC;IACJ,CAAC;IA7CD,sDA6CC;IAED,kBAAe,qBAAqB,CAAC","sourcesContent":["import { initializeElement, CustomElementDescriptor, handleAttributeChanged } from './customElements';\nimport { Constructor, WidgetProperties } from './interfaces';\nimport { WidgetBase } from './WidgetBase';\n\ndeclare namespace customElements {\n\tfunction define(name: string, constructor: any): void;\n}\n\n/**\n * Describes a function that returns a CustomElementDescriptor\n */\nexport interface CustomElementDescriptorFactory {\n\t(): CustomElementDescriptor;\n}\n\n/**\n * Register a custom element using the v1 spec of custom elements. Note that\n * this is the default export, and, expects the proposal to work in the browser.\n * This will likely require the polyfill and native shim.\n *\n * @param descriptorFactory\n */\nexport function registerCustomElement(descriptorFactory: CustomElementDescriptorFactory) {\n\tconst descriptor = descriptorFactory();\n\n\tcustomElements.define(descriptor.tagName, class extends HTMLElement {\n\t\tprivate _isAppended = false;\n\t\tprivate _appender: Function;\n\t\tprivate _widgetInstance: WidgetBase;\n\n\t\tconstructor() {\n\t\t\tsuper();\n\n\t\t\tthis._appender = initializeElement(this);\n\t\t}\n\n\t\tconnectedCallback() {\n\t\t\tif (!this._isAppended) {\n\t\t\t\tthis._appender();\n\t\t\t\tthis._isAppended = true;\n\t\t\t}\n\t\t}\n\n\t\tattributeChangedCallback(name: string, oldValue: string | null, newValue: string | null) {\n\t\t\thandleAttributeChanged(this, name, newValue, oldValue);\n\t\t}\n\n\t\tgetWidgetInstance(): WidgetBase<any> {\n\t\t\treturn this._widgetInstance;\n\t\t}\n\n\t\tsetWidgetInstance(widget: WidgetBase<any>): void {\n\t\t\tthis._widgetInstance = widget;\n\t\t}\n\n\t\tgetWidgetConstructor(): Constructor<WidgetBase<WidgetProperties>> {\n\t\t\treturn this.getDescriptor().widgetConstructor;\n\t\t}\n\n\t\tgetDescriptor(): CustomElementDescriptor {\n\t\t\treturn descriptor;\n\t\t}\n\n\t\tstatic get observedAttributes(): string[] {\n\t\t\treturn (descriptor.attributes || []).map(attribute => attribute.attributeName);\n\t\t}\n\t});\n}\n\nexport default registerCustomElement;\n"]}