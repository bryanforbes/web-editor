import { Evented } from '@dojo/core/Evented';
import { Constructor, WidgetProperties } from './../interfaces';
import { WidgetRegistry } from './../WidgetRegistry';
import { BaseInjector } from './../Injector';
import { WidgetBase } from './../WidgetBase';
/**
 * A representation of the css class names to be applied and
 * removed.
 */
export declare type ClassNameFlags = {
    [key: string]: boolean;
};
/**
 * A lookup object for available class names
 */
export declare type ClassNames = {
    [key: string]: string;
};
/**
 * Properties required for the themeable mixin
 */
export interface ThemeableProperties extends WidgetProperties {
    injectedTheme?: any;
    theme?: any;
    extraClasses?: any;
}
/**
 * Returned by classes function.
 */
export interface ClassesFunctionChain {
    (): ClassNameFlags;
    /**
     * The theme classes to be returned when get() is called
     */
    classes: string[];
    /**
     * The fixed classes to be returned when get() is called
     */
    fixedClasses: string[];
    /**
     * Function to pass fixed class names that bypass the theming
     * process
     */
    fixed: (...classes: (string | null)[]) => ClassesFunctionChain;
    /**
     * Finalize function to return the generated class names
     */
    get: () => ClassNameFlags;
}
export declare const INJECTED_THEME_KEY: symbol;
/**
 * Interface for the ThemeableMixin
 */
export interface ThemeableMixin {
    /**
     * Processes all the possible classes for the instance with setting the passed class names to
     * true.
     *
     * @param ...classNames an array of class names
     * @returns a function chain to `get` or process more classes using `fixed`
     */
    classes(...classNames: (string | null)[]): ClassesFunctionChain;
}
/**
 * Decorator for base css classes
 */
export declare function theme(theme: {}): (target: any, propertyKey?: string | undefined, descriptor?: PropertyDescriptor | undefined) => void;
/**
 * The class for the theme injector context, used to control the theme once the
 * theme injector has been defined in the registry.
 */
export declare class ThemeInjectorContext extends Evented {
    private _theme;
    /**
     * @param theme optional theme to initialize the context
     */
    constructor(theme?: any);
    /**
     * @param theme the theme object to set
     */
    set(theme: any): void;
    /**
     * Return the current theme
     */
    readonly theme: any;
}
/**
 * Custom `ThemeInjector` class that listens to the `invalidate` event
 * from the context to `invalidate` any widgets the have had a theme
 * injected.
 */
export declare class ThemeInjector extends BaseInjector<ThemeInjectorContext> {
    constructor(context: ThemeInjectorContext);
}
/**
 * Convenience function that is given a theme and an optional registry, the theme
 * injector is defined against the registry, returning the theme context.
 *
 * @param theme the theme to set
 * @param themeRegistry registry to define the theme injector against. Defaults
 * to the global registry
 *
 * @returns the theme context instance used to set the theme
 */
export declare function registerThemeInjector(theme: any, themeRegistry?: WidgetRegistry): ThemeInjectorContext;
/**
 * Function that returns a class decorated with with Themeable functionality
 */
export declare function ThemeableMixin<T extends Constructor<WidgetBase<ThemeableProperties>>>(base: T): T & Constructor<ThemeableMixin>;
export default ThemeableMixin;
