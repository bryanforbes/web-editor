var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "@dojo/core/lang", "@dojo/core/global", "@dojo/core/lang", "maquette", "pepjs", "../animations/cssTransitions"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var lang_1 = require("@dojo/core/lang");
    var global_1 = require("@dojo/core/global");
    var lang_2 = require("@dojo/core/lang");
    var maquette_1 = require("maquette");
    require("pepjs");
    var cssTransitions_1 = require("../animations/cssTransitions");
    /**
     * Represents the attach state of the projector
     */
    var ProjectorAttachState;
    (function (ProjectorAttachState) {
        ProjectorAttachState[ProjectorAttachState["Attached"] = 1] = "Attached";
        ProjectorAttachState[ProjectorAttachState["Detached"] = 2] = "Detached";
    })(ProjectorAttachState = exports.ProjectorAttachState || (exports.ProjectorAttachState = {}));
    /**
     * Attach type for the projector
     */
    var AttachType;
    (function (AttachType) {
        AttachType[AttachType["Append"] = 1] = "Append";
        AttachType[AttachType["Merge"] = 2] = "Merge";
        AttachType[AttachType["Replace"] = 3] = "Replace";
    })(AttachType = exports.AttachType || (exports.AttachType = {}));
    var eventHandlers = [
        'ontouchcancel',
        'ontouchend',
        'ontouchmove',
        'ontouchstart',
        'onblur',
        'onchange',
        'onclick',
        'ondblclick',
        'onfocus',
        'oninput',
        'onkeydown',
        'onkeypress',
        'onkeyup',
        'onload',
        'onmousedown',
        'onmouseenter',
        'onmouseleave',
        'onmousemove',
        'onmouseout',
        'onmouseover',
        'onmouseup',
        'onmousewheel',
        'onscroll',
        'onsubmit'
    ];
    /**
     * Internal function that maps existing DOM Elements to virtual DOM nodes.
     *
     * The funtion does not presume DOM will be there.  It does assume that if a DOM `Element` exists that the `VNode`s are in
     * the same DOM order as the `Element`s.  If a DOM Element does not exist, it will set the `vnode.domNode` to `null` and
     * not descend further into the `VNode` children which will cause the maquette projection to create the Element anew.
     * @param vnode The virtual DOM node
     * @param domNode The Element, if any, to set on the virtual DOM node
     */
    function setDomNodes(vnode, domNode) {
        if (domNode === void 0) { domNode = null; }
        vnode.domNode = domNode;
        if (vnode.children && domNode) {
            vnode.children.forEach(function (child, i) { return setDomNodes(child, domNode.children[i]); });
        }
    }
    function ProjectorMixin(Base) {
        var Projector = (function (_super) {
            __extends(Projector, _super);
            function Projector() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var _this = _super.apply(this, args) || this;
                _this._async = true;
                _this._projectionOptions = {
                    transitions: cssTransitions_1.default,
                    eventHandlerInterceptor: _this.eventHandlerInterceptor.bind(_this)
                };
                _this._boundDoRender = _this.doRender.bind(_this);
                _this._boundRender = _this.__render__.bind(_this);
                _this.own(_this.on('widget:children', _this.invalidate));
                _this.own(_this.on('properties:changed', function () {
                    _this.scheduleRender();
                }));
                _this.own(_this.on('invalidated', _this.scheduleRender));
                _this.root = document.body;
                _this.projectorState = ProjectorAttachState.Detached;
                return _this;
            }
            Projector.prototype.append = function (root) {
                var options = {
                    type: AttachType.Append,
                    root: root
                };
                return this.attach(options);
            };
            Projector.prototype.merge = function (root) {
                var options = {
                    type: AttachType.Merge,
                    root: root
                };
                return this.attach(options);
            };
            Projector.prototype.replace = function (root) {
                var options = {
                    type: AttachType.Replace,
                    root: root
                };
                return this.attach(options);
            };
            Projector.prototype.pause = function () {
                if (this._scheduled) {
                    global_1.default.cancelAnimationFrame(this._scheduled);
                    this._scheduled = undefined;
                }
                this._paused = true;
            };
            Projector.prototype.resume = function () {
                this._paused = false;
                this.scheduleRender();
            };
            Projector.prototype.scheduleRender = function () {
                if (this.projectorState === ProjectorAttachState.Attached && !this._scheduled && !this._paused) {
                    if (this._async) {
                        this._scheduled = global_1.default.requestAnimationFrame(this._boundDoRender);
                    }
                    else {
                        this._boundDoRender();
                    }
                }
            };
            Object.defineProperty(Projector.prototype, "root", {
                get: function () {
                    return this._root;
                },
                set: function (root) {
                    if (this.projectorState === ProjectorAttachState.Attached) {
                        throw new Error('Projector already attached, cannot change root element');
                    }
                    this._root = root;
                },
                enumerable: true,
                configurable: true
            });
            Projector.prototype.sandbox = function (doc) {
                var _this = this;
                if (doc === void 0) { doc = document; }
                if (this.projectorState === ProjectorAttachState.Attached) {
                    throw new Error('Projector already attached, cannot create sandbox');
                }
                this._async = false;
                var previousRoot = this.root;
                /* free up the document fragment for GC */
                this.own(lang_2.createHandle(function () {
                    _this._root = previousRoot;
                }));
                return this.attach({
                    /* DocumentFragment is not assignable to Element, but provides everything needed to work */
                    root: doc.createDocumentFragment(),
                    type: AttachType.Append
                });
            };
            Projector.prototype.setChildren = function (children) {
                this._projectorChildren = children.slice();
                _super.prototype.__setChildren__.call(this, children);
            };
            Projector.prototype.setProperties = function (properties) {
                this._projectorProperties = lang_1.assign({}, properties);
                _super.prototype.__setProperties__.call(this, properties);
            };
            Projector.prototype.toHtml = function () {
                if (this.projectorState !== ProjectorAttachState.Attached || !this._projection) {
                    throw new Error('Projector is not attached, cannot return an HTML string of projection.');
                }
                return this._projection.domNode.outerHTML;
            };
            Projector.prototype.__render__ = function () {
                if (this._projectorChildren) {
                    this.setChildren(this._projectorChildren);
                }
                if (this._projectorProperties) {
                    this.setProperties(this._projectorProperties);
                }
                var result = _super.prototype.__render__.call(this);
                if (Array.isArray(result) || typeof result === 'string' || result === null) {
                    if (!this._rootTagName) {
                        this._rootTagName = 'span';
                    }
                    result = maquette_1.h(this._rootTagName, {}, result);
                }
                else if (!this._rootTagName) {
                    this._rootTagName = result.vnodeSelector;
                }
                if (this._rootTagName !== result.vnodeSelector) {
                    if (this._attachType === AttachType.Merge) {
                        lang_1.assign(result, { vnodeSelector: this._rootTagName });
                    }
                    else {
                        result = maquette_1.h(this._rootTagName, {}, result);
                    }
                }
                return result;
            };
            Projector.prototype.eventHandlerInterceptor = function (propertyName, eventHandler, domNode, properties) {
                var _this = this;
                if (eventHandlers.indexOf(propertyName) > -1) {
                    return function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        return eventHandler.apply(properties.bind || this, args);
                    };
                }
                else {
                    // remove "on" from event name
                    var eventName = propertyName.substr(2);
                    domNode.addEventListener(eventName, function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        eventHandler.apply(properties.bind || _this, args);
                    });
                }
            };
            Projector.prototype.doRender = function () {
                this._scheduled = undefined;
                if (this._projection) {
                    this._projection.update(this._boundRender());
                }
            };
            Projector.prototype.attach = function (_a) {
                var _this = this;
                var type = _a.type, root = _a.root;
                this._attachType = type;
                if (root) {
                    this.root = root;
                }
                if (this.projectorState === ProjectorAttachState.Attached) {
                    return this._attachHandle;
                }
                this.projectorState = ProjectorAttachState.Attached;
                this._attachHandle = this.own({
                    destroy: function () {
                        if (_this.projectorState === ProjectorAttachState.Attached) {
                            _this.pause();
                            _this._projection = undefined;
                            _this.projectorState = ProjectorAttachState.Detached;
                        }
                        _this._attachHandle = { destroy: function () { } };
                    }
                });
                switch (type) {
                    case AttachType.Append:
                        this._projection = maquette_1.dom.append(this.root, this._boundRender(), this._projectionOptions);
                        break;
                    case AttachType.Merge:
                        this._rootTagName = this._root.tagName.toLowerCase();
                        var vnode = this._boundRender();
                        setDomNodes(vnode, this.root);
                        this._projection = maquette_1.dom.merge(this.root, vnode, this._projectionOptions);
                        break;
                    case AttachType.Replace:
                        this._projection = maquette_1.dom.replace(this.root, this._boundRender(), this._projectionOptions);
                        break;
                }
                return this._attachHandle;
            };
            return Projector;
        }(Base));
        return Projector;
    }
    exports.ProjectorMixin = ProjectorMixin;
    exports.default = ProjectorMixin;
});
//# sourceMappingURL=Projector.js.map