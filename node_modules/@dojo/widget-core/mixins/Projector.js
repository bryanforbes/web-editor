var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "@dojo/core/lang", "@dojo/shim/global", "@dojo/core/lang", "@dojo/core/Evented", "maquette", "pepjs", "../animations/cssTransitions", "./../decorators/afterRender", "./../d", "../util/eventHandlerInterceptor"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var lang_1 = require("@dojo/core/lang");
    var global_1 = require("@dojo/shim/global");
    var lang_2 = require("@dojo/core/lang");
    var Evented_1 = require("@dojo/core/Evented");
    var maquette_1 = require("maquette");
    require("pepjs");
    var cssTransitions_1 = require("../animations/cssTransitions");
    var afterRender_1 = require("./../decorators/afterRender");
    var d_1 = require("./../d");
    var eventHandlerInterceptor_1 = require("../util/eventHandlerInterceptor");
    /**
     * Represents the attach state of the projector
     */
    var ProjectorAttachState;
    (function (ProjectorAttachState) {
        ProjectorAttachState[ProjectorAttachState["Attached"] = 1] = "Attached";
        ProjectorAttachState[ProjectorAttachState["Detached"] = 2] = "Detached";
    })(ProjectorAttachState = exports.ProjectorAttachState || (exports.ProjectorAttachState = {}));
    /**
     * Attach type for the projector
     */
    var AttachType;
    (function (AttachType) {
        AttachType[AttachType["Append"] = 1] = "Append";
        AttachType[AttachType["Merge"] = 2] = "Merge";
        AttachType[AttachType["Replace"] = 3] = "Replace";
    })(AttachType = exports.AttachType || (exports.AttachType = {}));
    /**
     * Internal function that maps existing DOM Elements to virtual DOM nodes.
     *
     * The function does not presume DOM will be there.  It does assume that if a DOM `Element` exists that the `VNode`s are in
     * the same DOM order as the `Element`s.  If a DOM Element does not exist, it will set the `vnode.domNode` to `null` and
     * not descend further into the `VNode` children which will cause the maquette projection to create the Element anew.
     * @param vnode The virtual DOM node
     * @param domNode The Element, if any, to set on the virtual DOM node
     */
    function setDomNodes(vnode, domNode) {
        if (domNode === void 0) { domNode = null; }
        vnode.domNode = domNode;
        if (vnode.children && domNode) {
            vnode.children.forEach(function (child, i) { return setDomNodes(child, domNode.children[i]); });
        }
    }
    function ProjectorMixin(Base) {
        var Projector = /** @class */ (function (_super) {
            __extends(Projector, _super);
            function Projector() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var _this = _super.apply(this, args) || this;
                _this._async = true;
                _this._projectorChildren = [];
                _this._resetChildren = true;
                _this._projectorProperties = {};
                _this._resetProperties = true;
                var nodeEvent = new Evented_1.Evented();
                _this.own(nodeEvent);
                _this._projectionOptions = {
                    transitions: cssTransitions_1.default,
                    eventHandlerInterceptor: eventHandlerInterceptor_1.default.bind(_this),
                    nodeEvent: nodeEvent
                };
                _this._boundDoRender = _this._doRender.bind(_this);
                _this._boundRender = _this.__render__.bind(_this);
                _this.own(_this.on('invalidated', function () {
                    _this.scheduleRender();
                }));
                _this.root = document.body;
                _this.projectorState = ProjectorAttachState.Detached;
                return _this;
            }
            Projector.prototype.append = function (root) {
                var options = {
                    type: AttachType.Append,
                    root: root
                };
                return this._attach(options);
            };
            Projector.prototype.merge = function (root) {
                var options = {
                    type: AttachType.Merge,
                    root: root
                };
                return this._attach(options);
            };
            Projector.prototype.replace = function (root) {
                var options = {
                    type: AttachType.Replace,
                    root: root
                };
                return this._attach(options);
            };
            Projector.prototype.pause = function () {
                if (this._scheduled) {
                    global_1.default.cancelAnimationFrame(this._scheduled);
                    this._scheduled = undefined;
                }
                this._paused = true;
            };
            Projector.prototype.resume = function () {
                this._paused = false;
                this.scheduleRender();
            };
            Projector.prototype.scheduleRender = function () {
                if (this.projectorState === ProjectorAttachState.Attached && !this._scheduled && !this._paused) {
                    if (this._async) {
                        this._scheduled = global_1.default.requestAnimationFrame(this._boundDoRender);
                    }
                    else {
                        this._boundDoRender();
                    }
                }
            };
            Object.defineProperty(Projector.prototype, "root", {
                get: function () {
                    return this._root;
                },
                set: function (root) {
                    if (this.projectorState === ProjectorAttachState.Attached) {
                        throw new Error('Projector already attached, cannot change root element');
                    }
                    this._root = root;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Projector.prototype, "async", {
                get: function () {
                    return this._async;
                },
                set: function (async) {
                    if (this.projectorState === ProjectorAttachState.Attached) {
                        throw new Error('Projector already attached, cannot change async mode');
                    }
                    this._async = async;
                },
                enumerable: true,
                configurable: true
            });
            Projector.prototype.sandbox = function (doc) {
                var _this = this;
                if (doc === void 0) { doc = document; }
                if (this.projectorState === ProjectorAttachState.Attached) {
                    throw new Error('Projector already attached, cannot create sandbox');
                }
                this._async = false;
                var previousRoot = this.root;
                /* free up the document fragment for GC */
                this.own(lang_2.createHandle(function () {
                    _this._root = previousRoot;
                }));
                return this._attach({
                    /* DocumentFragment is not assignable to Element, but provides everything needed to work */
                    root: doc.createDocumentFragment(),
                    type: AttachType.Append
                });
            };
            Projector.prototype.setChildren = function (children) {
                this._resetChildren = false;
                this._projectorChildren = children.slice();
                _super.prototype.__setChildren__.call(this, children.slice());
            };
            Projector.prototype.setProperties = function (properties) {
                this._resetProperties = false;
                if (this._projectorProperties && this._projectorProperties.registry !== properties.registry) {
                    if (this._projectorProperties.registry) {
                        this._projectorProperties.registry.destroy();
                    }
                    if (properties.registry) {
                        this.own(properties.registry);
                    }
                }
                this._projectorProperties = lang_1.assign({}, properties);
                _super.prototype.__setCoreProperties__.call(this, { bind: this, baseRegistry: properties.registry });
                _super.prototype.__setProperties__.call(this, properties);
            };
            Projector.prototype.toHtml = function () {
                if (this.projectorState !== ProjectorAttachState.Attached || !this._projection) {
                    throw new Error('Projector is not attached, cannot return an HTML string of projection.');
                }
                return this._projection.domNode.outerHTML;
            };
            Projector.prototype.afterRender = function (result) {
                var node = result;
                if (Array.isArray(result) || typeof result === 'string' || result === null || result === undefined) {
                    if (!this._rootTagName) {
                        this._rootTagName = 'span';
                    }
                    node = d_1.v(this._rootTagName);
                    node.children = Array.isArray(result) ? result : [result];
                }
                else if (d_1.isHNode(node) && !this._rootTagName) {
                    this._rootTagName = node.tag;
                }
                if (d_1.isHNode(node)) {
                    if (this._rootTagName !== node.tag) {
                        if (this._attachType === AttachType.Merge) {
                            node.tag = this._rootTagName;
                        }
                        else {
                            node = d_1.v(this._rootTagName);
                            node.children = Array.isArray(result) ? result : [result];
                        }
                    }
                }
                return node;
            };
            Projector.prototype.__render__ = function () {
                if (this._resetChildren) {
                    this.setChildren(this._projectorChildren);
                }
                if (this._resetProperties) {
                    this.setProperties(this._projectorProperties);
                }
                this._resetChildren = true;
                this._resetProperties = true;
                return _super.prototype.__render__.call(this);
            };
            Projector.prototype.invalidate = function () {
                _super.prototype.invalidate.call(this);
                this.scheduleRender();
            };
            Projector.prototype._doRender = function () {
                this._scheduled = undefined;
                if (this._projection) {
                    this._projection.update(this._boundRender());
                    this._projectionOptions.nodeEvent.emit({ type: 'rendered' });
                }
            };
            Projector.prototype._attach = function (_a) {
                var _this = this;
                var type = _a.type, root = _a.root;
                this._attachType = type;
                if (root) {
                    this.root = root;
                }
                if (this.projectorState === ProjectorAttachState.Attached) {
                    return this._attachHandle;
                }
                this.projectorState = ProjectorAttachState.Attached;
                this._attachHandle = this.own({
                    destroy: function () {
                        if (_this.projectorState === ProjectorAttachState.Attached) {
                            _this.pause();
                            _this._projection = undefined;
                            _this.projectorState = ProjectorAttachState.Detached;
                        }
                        _this._attachHandle = { destroy: function () { } };
                    }
                });
                switch (type) {
                    case AttachType.Append:
                        this._projection = maquette_1.dom.append(this.root, this._boundRender(), this._projectionOptions);
                        break;
                    case AttachType.Merge:
                        this._rootTagName = this._root.tagName.toLowerCase();
                        var vnode = this._boundRender();
                        setDomNodes(vnode, this.root);
                        this._projection = maquette_1.dom.merge(this.root, vnode, this._projectionOptions);
                        break;
                    case AttachType.Replace:
                        this._projection = maquette_1.dom.replace(this.root, this._boundRender(), this._projectionOptions);
                        break;
                }
                this._projectionOptions.nodeEvent.emit({ type: 'rendered' });
                return this._attachHandle;
            };
            __decorate([
                afterRender_1.afterRender(),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", [Object]),
                __metadata("design:returntype", void 0)
            ], Projector.prototype, "afterRender", null);
            return Projector;
        }(Base));
        return Projector;
    }
    exports.ProjectorMixin = ProjectorMixin;
    exports.default = ProjectorMixin;
});
//# sourceMappingURL=Projector.js.map