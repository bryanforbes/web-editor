var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "@dojo/core/lang", "@dojo/shim/array", "@dojo/shim/Map", "./../Injector", "./../decorators/inject", "./../decorators/handleDecorator", "./../decorators/diffProperty", "./../diff"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var lang_1 = require("@dojo/core/lang");
    var array_1 = require("@dojo/shim/array");
    var Map_1 = require("@dojo/shim/Map");
    var Injector_1 = require("./../Injector");
    var inject_1 = require("./../decorators/inject");
    var handleDecorator_1 = require("./../decorators/handleDecorator");
    var diffProperty_1 = require("./../decorators/diffProperty");
    var diff_1 = require("./../diff");
    var THEME_KEY = ' _key';
    exports.INJECTED_THEME_KEY = Symbol('theme');
    /**
     * Decorator for base css classes
     */
    function theme(theme) {
        return handleDecorator_1.handleDecorator(function (target) {
            target.addDecorator('baseThemeClasses', theme);
        });
    }
    exports.theme = theme;
    /**
     * Split class strings containing spaces into separate array entries.
     * ie. ['class1 class2', 'class3] -> ['class1', 'class2', 'class3'];
     *
     * @param classes The array of class strings to split.
     * @return the complete classes array including any split classes.
     */
    function splitClassStrings(classes) {
        return classes.reduce(function (splitClasses, className) {
            if (className.indexOf(' ') > -1) {
                splitClasses.push.apply(splitClasses, className.split(' '));
            }
            else {
                splitClasses.push(className);
            }
            return splitClasses;
        }, []);
    }
    /**
     * Returns the class object map based on the class names and whether they are
     * active.
     *
     * @param className an array of string class names
     * @param applied indicates is the class is applied
     */
    function createClassNameObject(classNames, applied) {
        return classNames.reduce(function (flaggedClassNames, className) {
            flaggedClassNames[className] = applied;
            return flaggedClassNames;
        }, {});
    }
    /**
     * Creates a reverse lookup for the classes passed in via the `theme` function.
     *
     * @param classes The baseClasses object
     * @requires
     */
    function createThemeClassesLookup(classes) {
        return classes.reduce(function (currentClassNames, baseClass) {
            Object.keys(baseClass).forEach(function (key) {
                currentClassNames[baseClass[key]] = key;
            });
            return currentClassNames;
        }, {});
    }
    /**
     * Convenience function that is given a theme and an optional registry, the theme
     * injector is defined against the registry, returning the theme.
     *
     * @param theme the theme to set
     * @param themeRegistry registry to define the theme injector against. Defaults
     * to the global registry
     *
     * @returns the theme injector used to set the theme
     */
    function registerThemeInjector(theme, themeRegistry) {
        var themeInjector = new Injector_1.Injector(theme);
        themeRegistry.defineInjector(exports.INJECTED_THEME_KEY, themeInjector);
        return themeInjector;
    }
    exports.registerThemeInjector = registerThemeInjector;
    /**
     * Function that returns a class decorated with with Themeable functionality
     */
    function ThemeableMixin(Base) {
        var Themeable = (function (_super) {
            __extends(Themeable, _super);
            function Themeable() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * All classes ever seen by the instance
                 */
                _this._allClasses = {};
                /**
                 * Indicates if classes meta data need to be calculated.
                 */
                _this._recalculateClasses = true;
                /**
                 * Map of registered classes
                 */
                _this._registeredClassesMap = new Map_1.default();
                /**
                 * Loaded theme
                 */
                _this._theme = {};
                return _this;
            }
            /**
             * Function used to add themeable classes to a widget. Returns a chained function 'fixed'
             * that can be used to pass non-themeable classes to a widget. Filters out any null
             * values passed.
             *
             * @param classNames the classes to be added to the domNode. These classes must come from
             * the baseClasses passed into the @theme decorator.
             * @return A function chain containing the 'fixed' function and a 'get' finalizer function.
             * Class names passed to the 'fixed' function can be any string.
             *
             */
            Themeable.prototype.classes = function () {
                var classNames = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    classNames[_i] = arguments[_i];
                }
                if (this._recalculateClasses) {
                    this._recalculateThemeClasses();
                }
                var themeable = this;
                function classesGetter() {
                    var themeClasses = themeable._getThemeClasses(this.classes);
                    var fixedClasses = themeable._getFixedClasses(this.fixedClasses);
                    return lang_1.assign({}, themeable._allClasses, themeClasses, fixedClasses);
                }
                var classesFunctionChain = {
                    classes: classNames,
                    fixedClasses: [],
                    fixed: function () {
                        var classNames = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            classNames[_i] = arguments[_i];
                        }
                        var filteredClassNames = classNames.filter(function (className) { return className !== null; });
                        (_a = this.fixedClasses).push.apply(_a, filteredClassNames);
                        return this;
                        var _a;
                    },
                    get: classesGetter
                };
                return lang_1.assign(classesGetter.bind(classesFunctionChain), classesFunctionChain);
            };
            /**
             * Function fired when `theme` or `extraClasses` are changed.
             */
            Themeable.prototype.onPropertiesChanged = function () {
                this._recalculateClasses = true;
            };
            /**
             * Get theme class object from classNames
             */
            Themeable.prototype._getThemeClasses = function (classNames) {
                var _this = this;
                return classNames
                    .filter(function (className) { return !!className; })
                    .reduce(function (appliedClasses, className) {
                    if (!_this._baseThemeClassesReverseLookup[className]) {
                        console.warn("Class name: " + className + " not found, use chained 'fixed' method instead");
                        return appliedClasses;
                    }
                    className = _this._baseThemeClassesReverseLookup[className];
                    if (!_this._registeredClassesMap.has(className)) {
                        _this._registerThemeClass(className);
                    }
                    return lang_1.assign(appliedClasses, _this._registeredClassesMap.get(className));
                }, {});
            };
            /**
             * Get fixed class object from classNames
             */
            Themeable.prototype._getFixedClasses = function (classNames) {
                var splitClasses = splitClassStrings(classNames);
                this._appendToAllClassNames(splitClasses);
                return createClassNameObject(splitClasses, true);
            };
            /**
             * Adds classes to the internal allClasses property
             *
             * @param classNames an array of string class names
             */
            Themeable.prototype._appendToAllClassNames = function (classNames) {
                var negativeClassFlags = createClassNameObject(classNames, false);
                this._allClasses = lang_1.assign({}, this._allClasses, negativeClassFlags);
            };
            /**
             * Register the classes object for the class name and adds the class to the instances `allClasses` object.
             *
             * @param className the name of the class to register.
             */
            Themeable.prototype._registerThemeClass = function (className) {
                var _this = this;
                var _a = this.properties.extraClasses, extraClasses = _a === void 0 ? {} : _a;
                var themeClass = this._theme[className] ? this._theme[className] : this._getBaseThemeClass(className);
                var extraClassesClassNames = extraClasses[className];
                var extraClassesClassNamesArray = extraClassesClassNames ? extraClassesClassNames.split(' ') : [];
                var cssClassNames = themeClass.split(' ').concat(extraClassesClassNamesArray);
                var classesObject = cssClassNames.reduce(function (classesObject, cssClassName) {
                    classesObject[cssClassName] = true;
                    _this._allClasses[cssClassName] = false;
                    return classesObject;
                }, {});
                this._registeredClassesMap.set(className, classesObject);
            };
            /**
             * Recalculate registered classes for current theme.
             */
            Themeable.prototype._recalculateThemeClasses = function () {
                var _this = this;
                var _a = this.properties, _b = _a.injectedTheme, injectedTheme = _b === void 0 ? {} : _b, _c = _a.theme, theme = _c === void 0 ? injectedTheme : _c;
                if (!this._registeredBaseThemes) {
                    this._registeredBaseThemes = this.getDecorator('baseThemeClasses').slice();
                    this._checkForDuplicates();
                }
                var registeredBaseThemeKeys = this._registeredBaseThemes.map(function (registeredBaseThemeClasses) {
                    return registeredBaseThemeClasses[THEME_KEY];
                });
                this._baseThemeClassesReverseLookup = createThemeClassesLookup(this._registeredBaseThemes);
                this._theme = registeredBaseThemeKeys.reduce(function (baseTheme, themeKey) {
                    return lang_1.assign(baseTheme, theme[themeKey]);
                }, {});
                this._registeredClassesMap.forEach(function (value, key) {
                    _this._registerThemeClass(key);
                });
                this._recalculateClasses = false;
            };
            /**
             * Find the base theme class for the class name
             */
            Themeable.prototype._getBaseThemeClass = function (className) {
                var registeredBaseTheme = array_1.find(this._registeredBaseThemes, function (registeredBaseThemeClasses) {
                    return Boolean(registeredBaseThemeClasses[className]);
                });
                return (registeredBaseTheme && registeredBaseTheme[className]) || '';
            };
            /**
             * Check for duplicates across the registered base themes.
             */
            Themeable.prototype._checkForDuplicates = function () {
                var _this = this;
                this._registeredBaseThemes.forEach(function (registeredBaseThemeClasses, index) {
                    Object.keys(registeredBaseThemeClasses).some(function (key) {
                        return _this._isDuplicate(key, registeredBaseThemeClasses);
                    });
                });
            };
            /**
             * Search for the class name in other base themes
             */
            Themeable.prototype._isDuplicate = function (key, originatingBaseTheme) {
                var duplicate = false;
                if (key !== THEME_KEY) {
                    for (var i = 0; i < this._registeredBaseThemes.length; i++) {
                        if (originatingBaseTheme === this._registeredBaseThemes[i]) {
                            continue;
                        }
                        if (this._registeredBaseThemes[i][key]) {
                            console.warn("Duplicate base theme class key '" + key + "' detected, this could cause unexpected results");
                            duplicate = true;
                            break;
                        }
                    }
                    return duplicate;
                }
                return duplicate;
            };
            __decorate([
                diffProperty_1.diffProperty('theme', diff_1.shallow),
                diffProperty_1.diffProperty('extraClasses', diff_1.shallow),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", []),
                __metadata("design:returntype", void 0)
            ], Themeable.prototype, "onPropertiesChanged", null);
            Themeable = __decorate([
                inject_1.inject({
                    name: exports.INJECTED_THEME_KEY,
                    getProperties: function (theme, properties) {
                        if (!properties.theme) {
                            return { theme: theme };
                        }
                        return {};
                    }
                })
            ], Themeable);
            return Themeable;
        }(Base));
        return Themeable;
    }
    exports.ThemeableMixin = ThemeableMixin;
    exports.default = ThemeableMixin;
});
//# sourceMappingURL=Themeable.js.map