var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "@dojo/core/Evented", "@dojo/shim/Map", "@dojo/shim/Promise", "@dojo/shim/WeakMap", "./d", "./diff", "./RegistryHandler", "./NodeHandler", "./Registry"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Evented_1 = require("@dojo/core/Evented");
    var Map_1 = require("@dojo/shim/Map");
    require("@dojo/shim/Promise"); // Imported for side-effects
    var WeakMap_1 = require("@dojo/shim/WeakMap");
    var d_1 = require("./d");
    var diff_1 = require("./diff");
    var RegistryHandler_1 = require("./RegistryHandler");
    var NodeHandler_1 = require("./NodeHandler");
    var Registry_1 = require("./Registry");
    var WidgetRenderState;
    (function (WidgetRenderState) {
        WidgetRenderState[WidgetRenderState["IDLE"] = 1] = "IDLE";
        WidgetRenderState[WidgetRenderState["PROPERTIES"] = 2] = "PROPERTIES";
        WidgetRenderState[WidgetRenderState["CHILDREN"] = 3] = "CHILDREN";
        WidgetRenderState[WidgetRenderState["RENDER"] = 4] = "RENDER";
    })(WidgetRenderState || (WidgetRenderState = {}));
    var decoratorMap = new Map_1.default();
    var boundAuto = diff_1.auto.bind(null);
    /**
     * Main widget base for all widgets to extend
     */
    var WidgetBase = /** @class */ (function (_super) {
        __extends(WidgetBase, _super);
        /**
         * @constructor
         */
        function WidgetBase() {
            var _this = _super.call(this, {}) || this;
            /**
             * Array of property keys considered changed from the previous set properties
             */
            _this._changedPropertyKeys = [];
            /**
             * Core properties widget base sets for all widget
             */
            _this._coreProperties = {};
            _this._renderState = WidgetRenderState.IDLE;
            _this._metaMap = new WeakMap_1.default();
            _this._currentRootNode = 0;
            _this._numRootNodes = 0;
            _this._children = [];
            _this._decoratorCache = new Map_1.default();
            _this._properties = {};
            _this._cachedChildrenMap = new Map_1.default();
            _this._diffPropertyFunctionMap = new Map_1.default();
            _this._bindFunctionPropertyMap = new WeakMap_1.default();
            _this._registry = new RegistryHandler_1.default();
            _this._nodeHandler = new NodeHandler_1.default();
            _this.own(_this._registry);
            _this.own(_this._nodeHandler);
            _this._boundRenderFunc = _this.render.bind(_this);
            _this._boundInvalidate = _this.invalidate.bind(_this);
            _this.own(_this._registry.on('invalidate', _this._boundInvalidate));
            return _this;
        }
        WidgetBase.prototype.meta = function (MetaType) {
            var cached = this._metaMap.get(MetaType);
            if (!cached) {
                cached = new MetaType({
                    invalidate: this._boundInvalidate,
                    nodeHandler: this._nodeHandler
                });
                this._metaMap.set(MetaType, cached);
                this.own(cached);
            }
            return cached;
        };
        /**
         * vnode afterCreate callback that calls the onElementCreated lifecycle method.
         */
        WidgetBase.prototype._afterCreateCallback = function (element, projectionOptions, vnodeSelector, properties) {
            this._addElementToNodeHandler(element, projectionOptions, properties);
            this.onElementCreated(element, String(properties.key));
        };
        /**
         * vnode afterUpdate callback that calls the onElementUpdated lifecycle method.
         */
        WidgetBase.prototype._afterUpdateCallback = function (element, projectionOptions, vnodeSelector, properties) {
            this._addElementToNodeHandler(element, projectionOptions, properties);
            this.onElementUpdated(element, String(properties.key));
        };
        WidgetBase.prototype._addElementToNodeHandler = function (element, projectionOptions, properties) {
            var _this = this;
            var isRootNode = !properties.key || this._rootNodeKeys.indexOf(properties.key) > -1;
            var hasKey = !!properties.key;
            var isLastRootNode = false;
            if (isRootNode) {
                this._currentRootNode++;
                isLastRootNode = (this._currentRootNode === this._numRootNodes);
                if (this._projectorAttachEvent === undefined) {
                    this._projectorAttachEvent = projectionOptions.nodeEvent.on('rendered', function () {
                        _this._nodeHandler.addProjector();
                    });
                    this.own(this._projectorAttachEvent);
                }
            }
            if (isLastRootNode) {
                this._nodeHandler.addRoot(element, properties);
            }
            else if (hasKey) {
                this._nodeHandler.add(element, properties);
            }
        };
        /**
         * Widget lifecycle method that is called whenever a dom node is created for a vnode.
         * Override this method to access the dom nodes that were inserted into the dom.
         * @param element The dom node represented by the vdom node.
         * @param key The vdom node's key.
         */
        WidgetBase.prototype.onElementCreated = function (element, key) {
            // Do nothing by default.
        };
        /**
         * Widget lifecycle method that is called whenever a dom node that is associated with a vnode is updated.
         * Note: this method is dependant on the Maquette afterUpdate callback which is called if a dom
         * node might have been updated.  Maquette does not guarantee the dom node was updated.
         * Override this method to access the dom node.
         * @param element The dom node represented by the vdom node.
         * @param key The vdom node's key.
         */
        WidgetBase.prototype.onElementUpdated = function (element, key) {
            // Do nothing by default.
        };
        Object.defineProperty(WidgetBase.prototype, "properties", {
            get: function () {
                return this._properties;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WidgetBase.prototype, "changedPropertyKeys", {
            get: function () {
                return this._changedPropertyKeys.slice();
            },
            enumerable: true,
            configurable: true
        });
        WidgetBase.prototype.__setCoreProperties__ = function (coreProperties) {
            this._renderState = WidgetRenderState.PROPERTIES;
            var baseRegistry = coreProperties.baseRegistry;
            if (this._coreProperties.baseRegistry !== baseRegistry) {
                this._registry.base = baseRegistry;
                this.invalidate();
            }
            this._coreProperties = coreProperties;
        };
        WidgetBase.prototype.__setProperties__ = function (originalProperties) {
            var _this = this;
            var properties = this._runBeforeProperties(originalProperties);
            var changedPropertyKeys = [];
            var allProperties = Object.keys(properties).concat(Object.keys(this._properties));
            var checkedProperties = [];
            var diffPropertyResults = {};
            var registeredDiffPropertyNames = this.getDecorator('registeredDiffProperty');
            var runReactions = false;
            this._renderState = WidgetRenderState.PROPERTIES;
            for (var i = 0; i < allProperties.length; i++) {
                var propertyName = allProperties[i];
                if (checkedProperties.indexOf(propertyName) > 0) {
                    continue;
                }
                checkedProperties.push(propertyName);
                var previousProperty = this._properties[propertyName];
                var newProperty = this._bindFunctionProperty(properties[propertyName], this._coreProperties.bind);
                if (registeredDiffPropertyNames.indexOf(propertyName) !== -1) {
                    runReactions = true;
                    var diffFunctions = this.getDecorator("diffProperty:" + propertyName);
                    for (var i_1 = 0; i_1 < diffFunctions.length; i_1++) {
                        var result = diffFunctions[i_1](previousProperty, newProperty);
                        if (result.changed && changedPropertyKeys.indexOf(propertyName) === -1) {
                            changedPropertyKeys.push(propertyName);
                        }
                        if (propertyName in properties) {
                            diffPropertyResults[propertyName] = result.value;
                        }
                    }
                }
                else {
                    var result = boundAuto(previousProperty, newProperty);
                    if (result.changed && changedPropertyKeys.indexOf(propertyName) === -1) {
                        changedPropertyKeys.push(propertyName);
                    }
                    if (propertyName in properties) {
                        diffPropertyResults[propertyName] = result.value;
                    }
                }
            }
            if (runReactions) {
                this._mapDiffPropertyReactions(properties, changedPropertyKeys).forEach(function (args, reaction) {
                    if (args.changed) {
                        reaction.call(_this, args.previousProperties, args.newProperties);
                    }
                });
            }
            this._properties = diffPropertyResults;
            this._changedPropertyKeys = changedPropertyKeys;
            if (changedPropertyKeys.length > 0) {
                this.invalidate();
            }
        };
        Object.defineProperty(WidgetBase.prototype, "children", {
            get: function () {
                return this._children;
            },
            enumerable: true,
            configurable: true
        });
        WidgetBase.prototype.__setChildren__ = function (children) {
            this._renderState = WidgetRenderState.CHILDREN;
            if (this._children.length > 0 || children.length > 0) {
                this._children = children;
                this.invalidate();
            }
        };
        WidgetBase.prototype.__render__ = function () {
            this._renderState = WidgetRenderState.RENDER;
            if (this._dirty === true || this._cachedVNode === undefined) {
                this._dirty = false;
                var render = this._runBeforeRenders();
                var dNode = render();
                dNode = this.runAfterRenders(dNode);
                this._decorateNodes(dNode);
                var widget = this._dNodeToVNode(dNode);
                this._manageDetachedChildren();
                this._nodeHandler.clear();
                this._cachedVNode = widget;
                this._renderState = WidgetRenderState.IDLE;
                return widget;
            }
            this._renderState = WidgetRenderState.IDLE;
            return this._cachedVNode;
        };
        WidgetBase.prototype._decorateNodes = function (node) {
            var _this = this;
            var nodes = Array.isArray(node) ? node.slice() : [node];
            this._numRootNodes = nodes.length;
            this._currentRootNode = 0;
            var rootNodes = [];
            this._rootNodeKeys = [];
            nodes.forEach(function (node) {
                if (d_1.isHNode(node)) {
                    rootNodes.push(node);
                    node.properties = node.properties || {};
                    if (node.properties.key) {
                        _this._rootNodeKeys.push(node.properties.key);
                    }
                }
            });
            while (nodes.length) {
                var node_1 = nodes.pop();
                if (d_1.isHNode(node_1) || d_1.isWNode(node_1)) {
                    node_1.properties = node_1.properties || {};
                    if (d_1.isHNode(node_1)) {
                        if (rootNodes.indexOf(node_1) !== -1 || node_1.properties.key) {
                            node_1.properties.afterCreate = this._afterCreateCallback;
                            node_1.properties.afterUpdate = this._afterUpdateCallback;
                        }
                        if (node_1.properties.bind === undefined) {
                            node_1.properties.bind = this;
                        }
                    }
                    else {
                        if (!node_1.coreProperties) {
                            node_1.coreProperties = {
                                bind: this,
                                baseRegistry: this._coreProperties.baseRegistry
                            };
                        }
                    }
                    nodes = nodes.concat(node_1.children);
                }
            }
        };
        WidgetBase.prototype.invalidate = function () {
            if (this._renderState === WidgetRenderState.IDLE) {
                this._dirty = true;
                this.emit({
                    type: 'invalidated',
                    target: this
                });
            }
            else if (this._renderState === WidgetRenderState.PROPERTIES) {
                this._dirty = true;
            }
            else if (this._renderState === WidgetRenderState.CHILDREN) {
                this._dirty = true;
            }
        };
        WidgetBase.prototype.render = function () {
            return d_1.v('div', {}, this.children);
        };
        /**
         * Function to add decorators to WidgetBase
         *
         * @param decoratorKey The key of the decorator
         * @param value The value of the decorator
         */
        WidgetBase.prototype.addDecorator = function (decoratorKey, value) {
            value = Array.isArray(value) ? value : [value];
            if (this.hasOwnProperty('constructor')) {
                var decoratorList = decoratorMap.get(this.constructor);
                if (!decoratorList) {
                    decoratorList = new Map_1.default();
                    decoratorMap.set(this.constructor, decoratorList);
                }
                var specificDecoratorList = decoratorList.get(decoratorKey);
                if (!specificDecoratorList) {
                    specificDecoratorList = [];
                    decoratorList.set(decoratorKey, specificDecoratorList);
                }
                specificDecoratorList.push.apply(specificDecoratorList, value);
            }
            else {
                var decorators = this.getDecorator(decoratorKey);
                this._decoratorCache.set(decoratorKey, decorators.concat(value));
            }
        };
        /**
         * Function to build the list of decorators from the global decorator map.
         *
         * @param decoratorKey  The key of the decorator
         * @return An array of decorator values
         * @private
         */
        WidgetBase.prototype._buildDecoratorList = function (decoratorKey) {
            var allDecorators = [];
            var constructor = this.constructor;
            while (constructor) {
                var instanceMap = decoratorMap.get(constructor);
                if (instanceMap) {
                    var decorators = instanceMap.get(decoratorKey);
                    if (decorators) {
                        allDecorators.unshift.apply(allDecorators, decorators);
                    }
                }
                constructor = Object.getPrototypeOf(constructor);
            }
            return allDecorators;
        };
        /**
         * Function to retrieve decorator values
         *
         * @param decoratorKey The key of the decorator
         * @returns An array of decorator values
         */
        WidgetBase.prototype.getDecorator = function (decoratorKey) {
            var allDecorators = this._decoratorCache.get(decoratorKey);
            if (allDecorators !== undefined) {
                return allDecorators;
            }
            allDecorators = this._buildDecoratorList(decoratorKey);
            this._decoratorCache.set(decoratorKey, allDecorators);
            return allDecorators;
        };
        WidgetBase.prototype._mapDiffPropertyReactions = function (newProperties, changedPropertyKeys) {
            var _this = this;
            var reactionFunctions = this.getDecorator('diffReaction');
            return reactionFunctions.reduce(function (reactionPropertyMap, _a) {
                var reaction = _a.reaction, propertyName = _a.propertyName;
                var reactionArguments = reactionPropertyMap.get(reaction);
                if (reactionArguments === undefined) {
                    reactionArguments = {
                        previousProperties: {},
                        newProperties: {},
                        changed: false
                    };
                }
                reactionArguments.previousProperties[propertyName] = _this._properties[propertyName];
                reactionArguments.newProperties[propertyName] = newProperties[propertyName];
                if (changedPropertyKeys.indexOf(propertyName) !== -1) {
                    reactionArguments.changed = true;
                }
                reactionPropertyMap.set(reaction, reactionArguments);
                return reactionPropertyMap;
            }, new Map_1.default());
        };
        /**
         * Binds unbound property functions to the specified `bind` property
         *
         * @param properties properties to check for functions
         */
        WidgetBase.prototype._bindFunctionProperty = function (property, bind) {
            if (typeof property === 'function' && Registry_1.isWidgetBaseConstructor(property) === false) {
                var bindInfo = this._bindFunctionPropertyMap.get(property) || {};
                var boundFunc = bindInfo.boundFunc, scope = bindInfo.scope;
                if (boundFunc === undefined || scope !== bind) {
                    boundFunc = property.bind(bind);
                    this._bindFunctionPropertyMap.set(property, { boundFunc: boundFunc, scope: bind });
                }
                return boundFunc;
            }
            return property;
        };
        Object.defineProperty(WidgetBase.prototype, "registry", {
            get: function () {
                return this._registry;
            },
            enumerable: true,
            configurable: true
        });
        WidgetBase.prototype._runBeforeProperties = function (properties) {
            var _this = this;
            var beforeProperties = this.getDecorator('beforeProperties');
            if (beforeProperties.length > 0) {
                return beforeProperties.reduce(function (properties, beforePropertiesFunction) {
                    return __assign({}, properties, beforePropertiesFunction.call(_this, properties));
                }, __assign({}, properties));
            }
            return properties;
        };
        /**
         * Run all registered before renders and return the updated render method
         */
        WidgetBase.prototype._runBeforeRenders = function () {
            var _this = this;
            var beforeRenders = this.getDecorator('beforeRender');
            if (beforeRenders.length > 0) {
                return beforeRenders.reduce(function (render, beforeRenderFunction) {
                    var updatedRender = beforeRenderFunction.call(_this, render, _this._properties, _this._children);
                    if (!updatedRender) {
                        console.warn('Render function not returned from beforeRender, using previous render');
                        return render;
                    }
                    return updatedRender;
                }, this._boundRenderFunc);
            }
            return this._boundRenderFunc;
        };
        /**
         * Run all registered after renders and return the decorated DNodes
         *
         * @param dNode The DNodes to run through the after renders
         */
        WidgetBase.prototype.runAfterRenders = function (dNode) {
            var _this = this;
            var afterRenders = this.getDecorator('afterRender');
            if (afterRenders.length > 0) {
                return afterRenders.reduce(function (dNode, afterRenderFunction) {
                    return afterRenderFunction.call(_this, dNode);
                }, dNode);
            }
            return dNode;
        };
        WidgetBase.prototype._dNodeToVNode = function (dNode) {
            var _this = this;
            if (typeof dNode === 'string' || dNode === null || dNode === undefined) {
                return dNode;
            }
            if (Array.isArray(dNode)) {
                return dNode.map(function (node) { return _this._dNodeToVNode(node); });
            }
            if (d_1.isWNode(dNode)) {
                var children = dNode.children, properties = dNode.properties, coreProperties = dNode.coreProperties;
                var key = properties.key;
                var widgetConstructor = dNode.widgetConstructor;
                var child = void 0;
                if (!Registry_1.isWidgetBaseConstructor(widgetConstructor)) {
                    var item = this._registry.get(widgetConstructor);
                    if (item === null) {
                        return null;
                    }
                    widgetConstructor = item;
                }
                var childrenMapKey = key || widgetConstructor;
                var cachedChildren = this._cachedChildrenMap.get(childrenMapKey) || [];
                var cachedChild = void 0;
                for (var i = 0; i < cachedChildren.length; i++) {
                    var cachedChildWrapper = cachedChildren[i];
                    if (cachedChildWrapper.widgetConstructor === widgetConstructor && cachedChildWrapper.used === false) {
                        cachedChild = cachedChildWrapper;
                        break;
                    }
                }
                if (cachedChild !== undefined) {
                    child = cachedChild.child;
                    cachedChild.used = true;
                }
                else {
                    child = new widgetConstructor();
                    child.own(child.on('invalidated', this._boundInvalidate));
                    cachedChildren = cachedChildren.concat([{ child: child, widgetConstructor: widgetConstructor, used: true }]);
                    this._cachedChildrenMap.set(childrenMapKey, cachedChildren);
                    this.own(child);
                }
                child.__setCoreProperties__(coreProperties);
                child.__setProperties__(properties);
                if (typeof childrenMapKey !== 'string' && cachedChildren.length > 1) {
                    var widgetName = childrenMapKey.name;
                    var errorMsg = 'It is recommended to provide a unique \'key\' property when using the same widget multiple times';
                    if (widgetName) {
                        errorMsg = "It is recommended to provide a unique 'key' property when using the same widget (" + widgetName + ") multiple times";
                    }
                    console.warn(errorMsg);
                    this.emit({ type: 'error', target: this, error: new Error(errorMsg) });
                }
                child.__setChildren__(children);
                return child.__render__();
            }
            dNode.vNodes = [];
            for (var i = 0; i < dNode.children.length; i++) {
                var child = dNode.children[i];
                if (child === null || child === undefined) {
                    continue;
                }
                dNode.vNodes.push(this._dNodeToVNode(child));
            }
            return dNode.render();
        };
        /**
         * Manage widget instances after render processing
         */
        WidgetBase.prototype._manageDetachedChildren = function () {
            var _this = this;
            this._cachedChildrenMap.forEach(function (cachedChildren, key) {
                var filteredCacheChildren = [];
                for (var i = 0; i < cachedChildren.length; i++) {
                    var cachedChild = cachedChildren[i];
                    if (cachedChild.used === false) {
                        cachedChild.child.destroy();
                        continue;
                    }
                    cachedChild.used = false;
                    filteredCacheChildren.push(cachedChild);
                }
                _this._cachedChildrenMap.set(key, filteredCacheChildren);
            });
        };
        /**
         * static identifier
         */
        WidgetBase._type = Registry_1.WIDGET_BASE_TYPE;
        return WidgetBase;
    }(Evented_1.Evented));
    exports.WidgetBase = WidgetBase;
    exports.default = WidgetBase;
});
//# sourceMappingURL=WidgetBase.js.map