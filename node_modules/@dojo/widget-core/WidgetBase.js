var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "@dojo/core/Evented", "@dojo/shim/Map", "@dojo/shim/Set", "@dojo/shim/WeakMap", "./d", "./diff", "./RegistryHandler", "./WidgetRegistry"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Evented_1 = require("@dojo/core/Evented");
    var Map_1 = require("@dojo/shim/Map");
    var Set_1 = require("@dojo/shim/Set");
    var WeakMap_1 = require("@dojo/shim/WeakMap");
    var d_1 = require("./d");
    var diff_1 = require("./diff");
    var RegistryHandler_1 = require("./RegistryHandler");
    var WidgetRegistry_1 = require("./WidgetRegistry");
    var WidgetRenderState;
    (function (WidgetRenderState) {
        WidgetRenderState[WidgetRenderState["IDLE"] = 1] = "IDLE";
        WidgetRenderState[WidgetRenderState["PROPERTIES"] = 2] = "PROPERTIES";
        WidgetRenderState[WidgetRenderState["RENDER"] = 3] = "RENDER";
    })(WidgetRenderState || (WidgetRenderState = {}));
    var decoratorMap = new Map_1.default();
    function afterRender(method) {
        return handleDecorator(function (target, propertyKey) {
            target.addDecorator('afterRender', propertyKey ? target[propertyKey] : method);
        });
    }
    exports.afterRender = afterRender;
    function beforeRender(method) {
        return handleDecorator(function (target, propertyKey) {
            target.addDecorator('beforeRender', propertyKey ? target[propertyKey] : method);
        });
    }
    exports.beforeRender = beforeRender;
    /**
     * Decorator that can be used to register a function as a specific property diff
     *
     * @param propertyName  The name of the property of which the diff function is applied
     * @param diffType      The diff type, default is DiffType.AUTO.
     * @param diffFunction  A diff function to run if diffType if DiffType.CUSTOM
     */
    function diffProperty(propertyName, diffType, diffFunction) {
        if (diffType === void 0) { diffType = 6 /* AUTO */; }
        return handleDecorator(function (target, propertyKey) {
            target.addDecorator('diffProperty', {
                propertyName: propertyName,
                diffType: propertyKey ? 1 /* CUSTOM */ : diffType,
                diffFunction: propertyKey ? target[propertyKey] : diffFunction
            });
        });
    }
    exports.diffProperty = diffProperty;
    function onPropertiesChanged(method) {
        return handleDecorator(function (target, propertyKey) {
            target.addDecorator('onPropertiesChanged', propertyKey ? target[propertyKey] : method);
        });
    }
    exports.onPropertiesChanged = onPropertiesChanged;
    /**
     * Generic decorator handler to take care of whether or not the decorator was called at the class level
     * or the method level.
     *
     * @param handler
     */
    function handleDecorator(handler) {
        return function (target, propertyKey, descriptor) {
            if (typeof target === 'function') {
                handler(target.prototype, undefined);
            }
            else {
                handler(target, propertyKey);
            }
        };
    }
    exports.handleDecorator = handleDecorator;
    /**
     * Function that identifies DNodes that are HNodes with key properties.
     */
    function isHNodeWithKey(node) {
        return d_1.isHNode(node) && (node.properties != null) && (node.properties.key != null);
    }
    /**
     * Main widget base for all widgets to extend
     */
    var WidgetBase = WidgetBase_1 = (function (_super) {
        __extends(WidgetBase, _super);
        /**
         * @constructor
         */
        function WidgetBase() {
            var _this = _super.call(this, {}) || this;
            _this._renderState = WidgetRenderState.IDLE;
            _this._metaMap = new WeakMap_1.default();
            _this._nodeMap = new Map_1.default();
            _this._requiredNodes = new Set_1.default();
            _this._children = [];
            _this._decoratorCache = new Map_1.default();
            _this._properties = {};
            _this._previousProperties = {};
            _this._cachedChildrenMap = new Map_1.default();
            _this._diffPropertyFunctionMap = new Map_1.default();
            _this._renderDecorators = new Set_1.default();
            _this._bindFunctionPropertyMap = new WeakMap_1.default();
            _this._registries = new RegistryHandler_1.default();
            _this._registries.add(d_1.registry);
            _this.own(_this._registries);
            _this.own(_this._registries.on('invalidate', _this.invalidate.bind(_this)));
            _this.own(_this.on('properties:changed', function (evt) {
                _this._dirty = true;
                var propertiesChangedListeners = _this.getDecorator('onPropertiesChanged');
                propertiesChangedListeners.forEach(function (propertiesChangedFunction) {
                    propertiesChangedFunction.call(_this, evt);
                });
            }));
            _this._checkOnElementUsage();
            return _this;
        }
        WidgetBase.prototype.meta = function (MetaType) {
            var cached = this._metaMap.get(MetaType);
            if (!cached) {
                cached = new MetaType({
                    nodes: this._nodeMap,
                    requiredNodes: this._requiredNodes,
                    invalidate: this.invalidate.bind(this)
                });
                this._metaMap.set(MetaType, cached);
            }
            return cached;
        };
        /**
         * A render decorator that verifies nodes required in
         * 'meta' calls in this render,
         */
        WidgetBase.prototype.verifyRequiredNodes = function (renderFunc, properties, children) {
            var _this = this;
            return function () {
                _this._requiredNodes.forEach(function (element, key) {
                    if (!_this._nodeMap.has(key)) {
                        throw new Error("Required node " + key + " not found");
                    }
                });
                _this._requiredNodes.clear();
                return renderFunc();
            };
        };
        /**
         * A render decorator that clears the node map used
         * by 'meta' calls in this render.
         */
        WidgetBase.prototype.clearNodeMap = function (node) {
            this._nodeMap.clear();
            return node;
        };
        /**
         * A render decorator that registers vnode callbacks for 'afterCreate' and
         * 'afterUpdate' that will in turn call lifecycle methods onElementCreated and onElementUpdated.
         */
        WidgetBase.prototype.attachLifecycleCallbacks = function (node) {
            // Create vnode afterCreate and afterUpdate callback functions that will only be set on nodes
            // with "key" properties.
            var _this = this;
            d_1.decorate(node, function (node) {
                node.properties.afterCreate = _this._afterCreateCallback;
                node.properties.afterUpdate = _this._afterUpdateCallback;
            }, isHNodeWithKey);
            return node;
        };
        WidgetBase.prototype.decorateBind = function (node) {
            var _this = this;
            d_1.decorate(node, function (node) {
                var _a = node.properties, properties = _a === void 0 ? {} : _a;
                if (!properties.bind) {
                    properties.bind = _this;
                }
            }, function (node) {
                return d_1.isHNode(node) || d_1.isWNode(node);
            });
            return node;
        };
        /**
         * vnode afterCreate callback that calls the onElementCreated lifecycle method.
         */
        WidgetBase.prototype._afterCreateCallback = function (element, projectionOptions, vnodeSelector, properties) {
            this._setNode(element, properties);
            this.onElementCreated(element, String(properties.key));
        };
        /**
         * vnode afterUpdate callback that calls the onElementUpdated lifecycle method.
         */
        WidgetBase.prototype._afterUpdateCallback = function (element, projectionOptions, vnodeSelector, properties) {
            this._setNode(element, properties);
            this.onElementUpdated(element, String(properties.key));
        };
        /**
         * Widget lifecycle method that is called whenever a dom node is created for a vnode.
         * Override this method to access the dom nodes that were inserted into the dom.
         * @param element The dom node represented by the vdom node.
         * @param key The vdom node's key.
         */
        WidgetBase.prototype.onElementCreated = function (element, key) {
            // Do nothing by default.
        };
        /**
         * Widget lifecycle method that is called whenever a dom node that is associated with a vnode is updated.
         * Note: this method is dependant on the Maquette afterUpdate callback which is called if a dom
         * node might have been updated.  Maquette does not guarantee the dom node was updated.
         * Override this method to access the dom node.
         * @param element The dom node represented by the vdom node.
         * @param key The vdom node's key.
         */
        WidgetBase.prototype.onElementUpdated = function (element, key) {
            // Do nothing by default.
        };
        WidgetBase.prototype._setNode = function (element, properties) {
            this._nodeMap.set(String(properties.key), element);
        };
        Object.defineProperty(WidgetBase.prototype, "properties", {
            get: function () {
                return this._properties;
            },
            enumerable: true,
            configurable: true
        });
        WidgetBase.prototype.__setProperties__ = function (originalProperties) {
            var _this = this;
            var _a = originalProperties, bind = _a.bind, properties = __rest(_a, ["bind"]);
            this._renderState = WidgetRenderState.PROPERTIES;
            var diffPropertyResults = {};
            var diffPropertyChangedKeys = [];
            this._bindFunctionProperties(properties, bind);
            var registeredDiffPropertyConfigs = this.getDecorator('diffProperty');
            var allProperties = Object.keys(this._previousProperties).concat(Object.keys(properties)).filter(function (value, index, self) {
                return self.indexOf(value) === index;
            });
            var propertyDiffHandlers = allProperties.reduce(function (diffFunctions, propertyName) {
                diffFunctions[propertyName] = registeredDiffPropertyConfigs.filter(function (value) {
                    return value.propertyName === propertyName;
                }).slice();
                return diffFunctions;
            }, {});
            allProperties.forEach(function (propertyName) {
                var previousValue = _this._previousProperties[propertyName];
                var newValue = properties[propertyName];
                var diffHandlers = propertyDiffHandlers[propertyName];
                var result = {
                    changed: false,
                    value: newValue
                };
                if (diffHandlers.length) {
                    for (var i = 0; i < diffHandlers.length; i++) {
                        var _a = diffHandlers[i], diffFunction = _a.diffFunction, diffType = _a.diffType;
                        var meta = {
                            diffFunction: diffFunction,
                            scope: _this
                        };
                        result = diff_1.default(propertyName, diffType, previousValue, newValue, meta);
                        if (result.changed) {
                            break;
                        }
                    }
                }
                else {
                    result = diff_1.default(propertyName, 6 /* AUTO */, previousValue, newValue);
                }
                if (propertyName in properties) {
                    diffPropertyResults[propertyName] = result.value;
                }
                if (result.changed) {
                    diffPropertyChangedKeys.push(propertyName);
                }
            });
            this._properties = diffPropertyResults;
            if (diffPropertyChangedKeys.length) {
                this.emit({
                    type: 'properties:changed',
                    target: this,
                    properties: this.properties,
                    changedPropertyKeys: diffPropertyChangedKeys
                });
            }
            this._previousProperties = this.properties;
        };
        Object.defineProperty(WidgetBase.prototype, "children", {
            get: function () {
                return this._children;
            },
            enumerable: true,
            configurable: true
        });
        WidgetBase.prototype.__setChildren__ = function (children) {
            if (this._children.length || children.length) {
                this._dirty = true;
                this._children = children;
                this.emit({
                    type: 'widget:children',
                    target: this
                });
            }
        };
        WidgetBase.prototype.__render__ = function () {
            this._renderState = WidgetRenderState.RENDER;
            if (this._dirty || !this._cachedVNode) {
                this._dirty = false;
                var render = this._runBeforeRenders();
                var dNode = render();
                dNode = this._runAfterRenders(dNode);
                var widget = this._dNodeToVNode(dNode);
                this._manageDetachedChildren();
                if (widget) {
                    this._cachedVNode = widget;
                }
                this._renderState = WidgetRenderState.IDLE;
                return widget;
            }
            this._renderState = WidgetRenderState.IDLE;
            return this._cachedVNode;
        };
        WidgetBase.prototype.invalidate = function () {
            if (this._renderState === WidgetRenderState.IDLE) {
                this._dirty = true;
                this.emit({
                    type: 'invalidated',
                    target: this
                });
            }
            else if (this._renderState === WidgetRenderState.PROPERTIES) {
                this._dirty = true;
            }
        };
        WidgetBase.prototype.render = function () {
            return d_1.v('div', {}, this.children);
        };
        /**
         * Function to add decorators to WidgetBase
         *
         * @param decoratorKey The key of the decorator
         * @param value The value of the decorator
         */
        WidgetBase.prototype.addDecorator = function (decoratorKey, value) {
            value = Array.isArray(value) ? value : [value];
            if (this.hasOwnProperty('constructor')) {
                var decoratorList = decoratorMap.get(this.constructor);
                if (!decoratorList) {
                    decoratorList = new Map_1.default();
                    decoratorMap.set(this.constructor, decoratorList);
                }
                var specificDecoratorList = decoratorList.get(decoratorKey);
                if (!specificDecoratorList) {
                    specificDecoratorList = [];
                    decoratorList.set(decoratorKey, specificDecoratorList);
                }
                specificDecoratorList.push.apply(specificDecoratorList, value);
            }
            else {
                var decorators = this._decoratorCache.get(decoratorKey) || [];
                this._decoratorCache.set(decoratorKey, decorators.concat(value));
            }
        };
        /**
         * Function to build the list of decorators from the global decorator map.
         *
         * @param decoratorKey  The key of the decorator
         * @return An array of decorator values
         * @private
         */
        WidgetBase.prototype._buildDecoratorList = function (decoratorKey) {
            var allDecorators = [];
            var constructor = this.constructor;
            while (constructor) {
                var instanceMap = decoratorMap.get(constructor);
                if (instanceMap) {
                    var decorators = instanceMap.get(decoratorKey);
                    if (decorators) {
                        allDecorators.unshift.apply(allDecorators, decorators);
                    }
                }
                constructor = Object.getPrototypeOf(constructor);
            }
            return allDecorators;
        };
        /**
         * Function to retrieve decorator values
         *
         * @param decoratorKey The key of the decorator
         * @returns An array of decorator values
         */
        WidgetBase.prototype.getDecorator = function (decoratorKey) {
            var allDecorators = this._decoratorCache.get(decoratorKey);
            if (allDecorators !== undefined) {
                return allDecorators;
            }
            allDecorators = this._buildDecoratorList(decoratorKey);
            this._decoratorCache.set(decoratorKey, allDecorators);
            return allDecorators;
        };
        /**
         * Binds unbound property functions to the specified `bind` property
         *
         * @param properties properties to check for functions
         */
        WidgetBase.prototype._bindFunctionProperties = function (properties, bind) {
            var _this = this;
            Object.keys(properties).forEach(function (propertyKey) {
                var property = properties[propertyKey];
                if (typeof property === 'function' && !WidgetRegistry_1.isWidgetBaseConstructor(property)) {
                    var bindInfo = _this._bindFunctionPropertyMap.get(property) || {};
                    var boundFunc = bindInfo.boundFunc, scope = bindInfo.scope;
                    if (!boundFunc || scope !== bind) {
                        boundFunc = property.bind(bind);
                        _this._bindFunctionPropertyMap.set(property, { boundFunc: boundFunc, scope: bind });
                    }
                    properties[propertyKey] = boundFunc;
                }
            });
        };
        Object.defineProperty(WidgetBase.prototype, "registries", {
            get: function () {
                return this._registries;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Run all registered before renders and return the updated render method
         */
        WidgetBase.prototype._runBeforeRenders = function () {
            var _this = this;
            var beforeRenders = this.getDecorator('beforeRender');
            return beforeRenders.reduce(function (render, beforeRenderFunction) {
                var updatedRender = beforeRenderFunction.call(_this, render, _this._properties, _this._children);
                if (!updatedRender) {
                    console.warn('Render function not returned from beforeRender, using previous render');
                    return render;
                }
                return updatedRender;
            }, this.render.bind(this));
        };
        /**
         * Run all registered after renders and return the decorated DNodes
         *
         * @param dNode The DNodes to run through the after renders
         */
        WidgetBase.prototype._runAfterRenders = function (dNode) {
            var _this = this;
            var afterRenders = this.getDecorator('afterRender');
            return afterRenders.reduce(function (dNode, afterRenderFunction) {
                var updatedDNode = afterRenderFunction.call(_this, dNode);
                if (!updatedDNode) {
                    console.warn('DNodes not returned from afterRender, using existing dNodes');
                    return dNode;
                }
                return updatedDNode;
            }, dNode);
        };
        WidgetBase.prototype._dNodeToVNode = function (dNode) {
            var _this = this;
            if (typeof dNode === 'string' || dNode === null || dNode === undefined) {
                return dNode;
            }
            if (Array.isArray(dNode)) {
                return dNode.map(function (node) { return _this._dNodeToVNode(node); });
            }
            if (d_1.isWNode(dNode)) {
                var children = dNode.children, _a = dNode.properties, properties = _a === void 0 ? {} : _a;
                var key = properties.key;
                var widgetConstructor_1 = dNode.widgetConstructor;
                var child = void 0;
                if (!WidgetRegistry_1.isWidgetBaseConstructor(widgetConstructor_1)) {
                    var item = this._registries.get(widgetConstructor_1);
                    if (item === null) {
                        return null;
                    }
                    widgetConstructor_1 = item;
                }
                var childrenMapKey = key || widgetConstructor_1;
                var cachedChildren = this._cachedChildrenMap.get(childrenMapKey) || [];
                var cachedChild_1;
                cachedChildren.some(function (cachedChildWrapper) {
                    if (cachedChildWrapper.widgetConstructor === widgetConstructor_1 && !cachedChildWrapper.used) {
                        cachedChild_1 = cachedChildWrapper;
                        return true;
                    }
                    return false;
                });
                if (cachedChild_1) {
                    child = cachedChild_1.child;
                    child.__setProperties__(properties);
                    cachedChild_1.used = true;
                }
                else {
                    child = new widgetConstructor_1();
                    child.__setProperties__(properties);
                    child.own(child.on('invalidated', function () {
                        _this.invalidate();
                    }));
                    cachedChildren = cachedChildren.concat([{ child: child, widgetConstructor: widgetConstructor_1, used: true }]);
                    this._cachedChildrenMap.set(childrenMapKey, cachedChildren);
                    this.own(child);
                }
                if (typeof childrenMapKey !== 'string' && cachedChildren.length > 1) {
                    var widgetName = childrenMapKey.name;
                    var errorMsg = 'It is recommended to provide a unique \'key\' property when using the same widget multiple times';
                    if (widgetName) {
                        errorMsg = "It is recommended to provide a unique 'key' property when using the same widget (" + widgetName + ") multiple times";
                    }
                    console.warn(errorMsg);
                    this.emit({ type: 'error', target: this, error: new Error(errorMsg) });
                }
                child.__setChildren__(children);
                return child.__render__();
            }
            dNode.vNodes = dNode.children
                .filter(function (child) { return child !== null && child !== undefined; })
                .map(function (child) {
                return _this._dNodeToVNode(child);
            });
            return dNode.render();
        };
        /**
         * Manage widget instances after render processing
         */
        WidgetBase.prototype._manageDetachedChildren = function () {
            var _this = this;
            this._cachedChildrenMap.forEach(function (cachedChildren, key) {
                var filterCachedChildren = cachedChildren.filter(function (cachedChild) {
                    if (cachedChild.used) {
                        cachedChild.used = false;
                        return true;
                    }
                    cachedChild.child.destroy();
                    return false;
                });
                _this._cachedChildrenMap.set(key, filterCachedChildren);
            });
        };
        WidgetBase.prototype._checkOnElementUsage = function () {
            var name = this.constructor.name || 'unknown';
            if (this.onElementCreated !== WidgetBase_1.prototype.onElementCreated) {
                console.warn("Usage of 'onElementCreated' has been deprecated and will be removed in a future version, see https://github.com/dojo/widget-core/issues/559 for details (" + name + ")");
            }
            if (this.onElementUpdated !== WidgetBase_1.prototype.onElementUpdated) {
                console.warn("Usage of 'onElementUpdated' has been deprecated and will be removed in a future version, see https://github.com/dojo/widget-core/issues/559 for details (" + name + ")");
            }
        };
        return WidgetBase;
    }(Evented_1.Evented));
    /**
     * static identifier
     */
    WidgetBase._type = WidgetRegistry_1.WIDGET_BASE_TYPE;
    __decorate([
        beforeRender(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Function, Object, Array]),
        __metadata("design:returntype", Function)
    ], WidgetBase.prototype, "verifyRequiredNodes", null);
    __decorate([
        afterRender(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", Object)
    ], WidgetBase.prototype, "clearNodeMap", null);
    __decorate([
        afterRender(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", Object)
    ], WidgetBase.prototype, "attachLifecycleCallbacks", null);
    __decorate([
        afterRender(),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", Object)
    ], WidgetBase.prototype, "decorateBind", null);
    WidgetBase = WidgetBase_1 = __decorate([
        diffProperty('bind', 4 /* REFERENCE */),
        __metadata("design:paramtypes", [])
    ], WidgetBase);
    exports.WidgetBase = WidgetBase;
    exports.default = WidgetBase;
    var WidgetBase_1;
});
//# sourceMappingURL=WidgetBase.js.map