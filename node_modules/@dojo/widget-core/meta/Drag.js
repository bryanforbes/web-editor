var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "@dojo/core/lang", "@dojo/shim/global", "@dojo/shim/object", "@dojo/shim/WeakMap", "./Base"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var lang_1 = require("@dojo/core/lang");
    var global_1 = require("@dojo/shim/global");
    var object_1 = require("@dojo/shim/object");
    var WeakMap_1 = require("@dojo/shim/WeakMap");
    var Base_1 = require("./Base");
    function createNodeData(invalidate) {
        return {
            dragResults: lang_1.deepAssign({}, emptyResults),
            invalidate: invalidate,
            last: createPosition(),
            start: createPosition()
        };
    }
    /**
     * Creates an empty position
     */
    function createPosition() {
        return { x: 0, y: 0 };
    }
    /**
     * A frozen empty result object, frozen to ensure that no one downstream modifies it
     */
    var emptyResults = Object.freeze({
        delta: Object.freeze(createPosition()),
        isDragging: false
    });
    /**
     * Return the x/y position for an event
     * @param event The pointer event
     */
    function getPosition(event) {
        return {
            x: event.pageX,
            y: event.pageY
        };
    }
    /**
     * Return the delta position between two positions
     * @param start The first position
     * @param current The second position
     */
    function getDelta(start, current) {
        return {
            x: current.x - start.x,
            y: current.y - start.y
        };
    }
    var DragController = (function () {
        function DragController() {
            var _this = this;
            this._nodeMap = new WeakMap_1.default();
            this._dragging = undefined;
            this._onDragStart = function (e) {
                var data = _this._getData(e.target);
                if (data) {
                    var state = data.state, target = data.target;
                    _this._dragging = target;
                    state.dragResults.isDragging = true;
                    state.last = state.start = getPosition(e);
                    state.dragResults.delta = createPosition();
                    state.invalidate();
                } // else, we are ignoring the event
            };
            this._onDrag = function (e) {
                var _dragging = _this._dragging;
                if (!_dragging) {
                    return;
                }
                // state cannot be unset, using ! operator
                var state = _this._nodeMap.get(_dragging);
                state.last = getPosition(e);
                state.dragResults.delta = getDelta(state.start, state.last);
                state.invalidate();
            };
            this._onDragStop = function (e) {
                var _dragging = _this._dragging;
                if (!_dragging) {
                    return;
                }
                // state cannot be unset, using ! operator
                var state = _this._nodeMap.get(_dragging);
                state.last = getPosition(e);
                state.dragResults = {
                    delta: getDelta(state.start, state.last),
                    isDragging: false
                };
                state.invalidate();
                _this._dragging = undefined;
            };
            var win = global_1.default.window;
            win.addEventListener('pointerdown', this._onDragStart);
            // Use capture phase, to determine the right node target, as it will be top down versus bottom up
            win.addEventListener('pointermove', this._onDrag, true);
            win.addEventListener('pointerup', this._onDragStop, true);
        }
        DragController.prototype._getData = function (target) {
            if (this._nodeMap.has(target)) {
                return { state: this._nodeMap.get(target), target: target };
            }
            if (target.parentElement) {
                return this._getData(target.parentElement);
            }
        };
        DragController.prototype.get = function (node, invalidate) {
            var _nodeMap = this._nodeMap;
            // first time we see a node, we will initialize its state
            if (!_nodeMap.has(node)) {
                _nodeMap.set(node, createNodeData(invalidate));
                return emptyResults;
            }
            var state = _nodeMap.get(node);
            // we are offering up an accurate delta, so we need to take the last event position and move it to the start so
            // that our deltas are calculated from the last time they are read
            state.start = state.last;
            // shallow "clone" the results, so no downstream manipulation can occur
            var dragResults = object_1.assign({}, state.dragResults);
            // reset the delta after we have read any last delta while not dragging
            if (!dragResults.isDragging && dragResults.delta.x !== 0 && dragResults.delta.y !== 0) {
                // future reads of the delta will be blank
                state.dragResults.delta = createPosition();
            }
            return dragResults;
        };
        return DragController;
    }());
    var controller = new DragController();
    var Drag = (function (_super) {
        __extends(Drag, _super);
        function Drag() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._boundInvalidate = _this.invalidate.bind(_this);
            return _this;
        }
        Drag.prototype.get = function (key) {
            var node = this.getNode(key);
            // if we don't have a reference to the node yet, return an empty set of results
            if (!node) {
                return emptyResults;
            }
            // otherwise we will ask the controller for our results
            return controller.get(node, this._boundInvalidate);
        };
        return Drag;
    }(Base_1.Base));
    exports.Drag = Drag;
    exports.default = Drag;
});
//# sourceMappingURL=Drag.js.map