{"version":3,"file":"Drag.js","sourceRoot":"","sources":["Drag.ts"],"names":[],"mappings":"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","sourcesContent":["import { deepAssign } from '@dojo/core/lang';\nimport global from '@dojo/shim/global';\nimport { assign } from '@dojo/shim/object';\nimport WeakMap from '@dojo/shim/WeakMap';\nimport { Base } from './Base';\n\nexport interface DragResults {\n\t/**\n\t * The movement of pointer during the duration of the drag state\n\t */\n\tdelta: Position;\n\n\t/**\n\t * Is the DOM node currently in a drag state\n\t */\n\tisDragging: boolean;\n}\n\ninterface NodeData {\n\tdragResults: DragResults;\n\tinvalidate: () => void;\n\tlast: Position;\n\tstart: Position;\n}\n\nexport interface Position {\n\tx: number;\n\ty: number;\n}\n\nfunction createNodeData(invalidate: () => void): NodeData {\n\treturn {\n\t\tdragResults: deepAssign({}, emptyResults),\n\t\tinvalidate,\n\t\tlast: createPosition(),\n\t\tstart: createPosition()\n\t};\n}\n\n/**\n * Creates an empty position\n */\nfunction createPosition(): Position {\n\treturn { x: 0, y: 0 };\n}\n\n/**\n * A frozen empty result object, frozen to ensure that no one downstream modifies it\n */\nconst emptyResults = Object.freeze({\n\tdelta: Object.freeze(createPosition()),\n\tisDragging: false\n});\n\n/**\n * Return the x/y position for an event\n * @param event The pointer event\n */\nfunction getPosition(event: PointerEvent): Position {\n\treturn {\n\t\tx: event.pageX,\n\t\ty: event.pageY\n\t};\n}\n\n/**\n * Return the delta position between two positions\n * @param start The first position\n * @param current The second position\n */\nfunction getDelta(start: Position, current: Position): Position {\n\treturn {\n\t\tx: current.x - start.x,\n\t\ty: current.y - start.y\n\t};\n}\n\nclass DragController {\n\tprivate _nodeMap = new WeakMap<HTMLElement, NodeData>();\n\tprivate _dragging: HTMLElement | undefined = undefined;\n\n\tprivate _getData(target: HTMLElement): { state: NodeData, target: HTMLElement } | undefined {\n\t\tif (this._nodeMap.has(target)) {\n\t\t\treturn { state: this._nodeMap.get(target)!, target };\n\t\t}\n\t\tif (target.parentElement) {\n\t\t\treturn this._getData(target.parentElement);\n\t\t}\n\t}\n\n\tprivate _onDragStart = (e: PointerEvent) => {\n\t\tconst data = this._getData(e.target as HTMLElement);\n\t\tif (data) {\n\t\t\tconst { state, target } = data;\n\t\t\tthis._dragging = target;\n\t\t\tstate.dragResults.isDragging = true;\n\t\t\tstate.last = state.start = getPosition(e);\n\t\t\tstate.dragResults.delta = createPosition();\n\t\t\tstate.invalidate();\n\t\t} // else, we are ignoring the event\n\t}\n\n\tprivate _onDrag = (e: PointerEvent) => {\n\t\tconst { _dragging } = this;\n\t\tif (!_dragging) {\n\t\t\treturn;\n\t\t}\n\t\t// state cannot be unset, using ! operator\n\t\tconst state = this._nodeMap.get(_dragging)!;\n\t\tstate.last = getPosition(e);\n\t\tstate.dragResults.delta = getDelta(state.start, state.last);\n\t\tstate.invalidate();\n\t}\n\n\tprivate _onDragStop = (e: PointerEvent) => {\n\t\tconst { _dragging } = this;\n\t\tif (!_dragging) {\n\t\t\treturn;\n\t\t}\n\t\t// state cannot be unset, using ! operator\n\t\tconst state = this._nodeMap.get(_dragging)!;\n\t\tstate.last = getPosition(e);\n\t\tstate.dragResults = {\n\t\t\tdelta: getDelta(state.start, state.last),\n\t\t\tisDragging: false\n\t\t};\n\t\tstate.invalidate();\n\t\tthis._dragging = undefined;\n\t}\n\n\tconstructor() {\n\t\tconst win: Window = global.window;\n\t\twin.addEventListener('pointerdown', this._onDragStart);\n\t\t// Use capture phase, to determine the right node target, as it will be top down versus bottom up\n\t\twin.addEventListener('pointermove', this._onDrag, true);\n\t\twin.addEventListener('pointerup', this._onDragStop, true);\n\t}\n\n\tpublic get(node: HTMLElement, invalidate: () => void): DragResults {\n\t\tconst { _nodeMap } = this;\n\t\t// first time we see a node, we will initialize its state\n\t\tif (!_nodeMap.has(node)) {\n\t\t\t_nodeMap.set(node, createNodeData(invalidate));\n\t\t\treturn emptyResults;\n\t\t}\n\n\t\tconst state = _nodeMap.get(node)!;\n\t\t// we are offering up an accurate delta, so we need to take the last event position and move it to the start so\n\t\t// that our deltas are calculated from the last time they are read\n\t\tstate.start = state.last;\n\t\t// shallow \"clone\" the results, so no downstream manipulation can occur\n\t\tconst dragResults = assign({}, state.dragResults);\n\n\t\t// reset the delta after we have read any last delta while not dragging\n\t\tif (!dragResults.isDragging && dragResults.delta.x !== 0 && dragResults.delta.y !== 0) {\n\t\t\t// future reads of the delta will be blank\n\t\t\tstate.dragResults.delta = createPosition();\n\t\t}\n\n\t\treturn dragResults;\n\t}\n}\n\nconst controller = new DragController();\n\nexport class Drag extends Base {\n\tprivate _boundInvalidate: () => void = this.invalidate.bind(this);\n\n\tpublic get(key: string): Readonly<DragResults> {\n\t\tconst node = this.getNode(key);\n\n\t\t// if we don't have a reference to the node yet, return an empty set of results\n\t\tif (!node) {\n\t\t\treturn emptyResults;\n\t\t}\n\n\t\t// otherwise we will ask the controller for our results\n\t\treturn controller.get(node, this._boundInvalidate);\n\t}\n}\n\nexport default Drag;\n"]}