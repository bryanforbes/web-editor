var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "@dojo/shim/Map", "./aspect", "./Destroyable"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Map_1 = require("@dojo/shim/Map");
    var aspect_1 = require("./aspect");
    var Destroyable_1 = require("./Destroyable");
    /**
     * Determines is the value is Actionable (has a `.do` function)
     *
     * @param value the value to check
     * @returns boolean indicating is the value is Actionable
     */
    function isActionable(value) {
        return Boolean(value && typeof value.do === 'function');
    }
    /**
     * Resolve listeners.
     */
    function resolveListener(listener) {
        return isActionable(listener) ? function (event) { return listener.do({ event: event }); } : listener;
    }
    /**
     * Handles an array of handles
     *
     * @param handles an array of handles
     * @returns a single Handle for handles passed
     */
    function handlesArraytoHandle(handles) {
        return {
            destroy: function () {
                handles.forEach(function (handle) { return handle.destroy(); });
            }
        };
    }
    /**
     * Map of computed regular expressions, keyed by string
     */
    var regexMap = new Map_1.default();
    /**
     * Determines is the event type glob has been matched
     *
     * @returns boolean that indicates if the glob is matched
     */
    function isGlobMatch(globString, targetString) {
        if (globString.indexOf('*') !== -1) {
            var regex = void 0;
            if (regexMap.has(globString)) {
                regex = regexMap.get(globString);
            }
            else {
                regex = new RegExp("^" + globString.replace(/\*/g, '.*') + "$");
                regexMap.set(globString, regex);
            }
            return regex.test(targetString);
        }
        else {
            return globString === targetString;
        }
    }
    exports.isGlobMatch = isGlobMatch;
    /**
     * Event Class
     */
    var Evented = (function (_super) {
        __extends(Evented, _super);
        /**
         * @constructor
         * @param options The constructor argurments
         */
        function Evented(options) {
            if (options === void 0) { options = {}; }
            var _this = _super.call(this) || this;
            /**
             * map of listeners keyed by event type
             */
            _this.listenersMap = new Map_1.default();
            /**
             * Catch all handler for various call signatures. The signatures are defined in
             * `BaseEventedEvents`.  You can add your own event type -> handler types by extending
             * `BaseEventedEvents`.  See example for details.
             *
             * @param args
             *
             * @example
             *
             * interface WidgetBaseEvents extends BaseEventedEvents {
             *     (type: 'properties:changed', handler: PropertiesChangedHandler): Handle;
             * }
             * class WidgetBase extends Evented {
             *    on: WidgetBaseEvents;
             * }
             *
             * @return {any}
             */
            _this.on = function () {
                var _this = this;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                if (args.length === 2) {
                    var _a = args, type_1 = _a[0], listeners = _a[1];
                    if (Array.isArray(listeners)) {
                        var handles = listeners.map(function (listener) { return aspect_1.on(_this.listenersMap, type_1, resolveListener(listener)); });
                        return handlesArraytoHandle(handles);
                    }
                    else {
                        return aspect_1.on(this.listenersMap, type_1, resolveListener(listeners));
                    }
                }
                else if (args.length === 1) {
                    var listenerMapArg_1 = args[0];
                    var handles = Object.keys(listenerMapArg_1).map(function (type) { return _this.on(type, listenerMapArg_1[type]); });
                    return handlesArraytoHandle(handles);
                }
                else {
                    throw new TypeError('Invalid arguments');
                }
            };
            var listeners = options.listeners;
            if (listeners) {
                _this.own(_this.on(listeners));
            }
            return _this;
        }
        /**
         * Emits the event objet for the specified type
         *
         * @param event the event to emit
         */
        Evented.prototype.emit = function (event) {
            var _this = this;
            this.listenersMap.forEach(function (method, type) {
                if (isGlobMatch(type, event.type)) {
                    method.call(_this, event);
                }
            });
        };
        return Evented;
    }(Destroyable_1.Destroyable));
    exports.Evented = Evented;
    exports.default = Evented;
});
//# sourceMappingURL=Evented.js.map