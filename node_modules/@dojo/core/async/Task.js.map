{"version":3,"file":"Task.js","sourceRoot":"","sources":["Task.ts"],"names":[],"mappings":"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","sourcesContent":["import { Thenable } from '@dojo/shim/interfaces';\nimport { Executor } from '@dojo/shim/Promise';\nimport ExtensiblePromise, { ListOfPromises, DictionaryOfPromises } from './ExtensiblePromise';\nimport { Iterable } from '@dojo/shim/iterator';\n\n/**\n * Describe the internal state of a task.\n */\nexport declare const enum State {\n\tFulfilled = 0,\n\tPending = 1,\n\tRejected = 2,\n\tCanceled = 3\n}\n\n/**\n * A type guard that determines if `value` is a `Task`\n * @param value The value to guard\n */\nexport function isTask<T>(value: any): value is Task<T> {\n\treturn Boolean(value && typeof value.cancel === 'function' && Array.isArray(value.children) && isThenable(value));\n}\n\n/**\n * Returns true if a given value has a `then` method.\n * @param {any} value The value to check if is Thenable\n * @returns {is Thenable<T>} A type guard if the value is thenable\n */\nexport function isThenable<T>(value: any): value is Thenable<T> {\n\treturn value && typeof value.then === 'function';\n}\n\n/**\n * Task is an extension of Promise that supports cancellation and the Task#finally method.\n */\nexport default class Task<T> extends ExtensiblePromise<T> {\n\t/**\n\t * Return a Task that resolves when one of the passed in objects have resolved\n\t *\n\t * @param iterable    An iterable of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n\t * @returns {Task}\n\t */\n\tstatic race<F extends ExtensiblePromise<T>, T>(iterable: Iterable<(T | Thenable<T>)> | (T | Thenable<T>)[]): Task<T> {\n\t\treturn <Task<T>> super.race(iterable);\n\t}\n\n\t/**\n\t * Return a rejected promise wrapped in a Task\n\t *\n\t * @param {Error?} reason    The reason for the rejection\n\t * @returns {Task}\n\t */\n\tstatic reject<T>(reason?: Error): Task<T> {\n\t\treturn new this<T>((resolve, reject) => reject(reason));\n\t}\n\n\t/**\n\t * Return a resolved task.\n\t *\n\t * @param value The value to resolve with\n\t *\n\t * @return {Task}\n\t */\n\tpublic static resolve(): Task<void>;\n\tpublic static resolve<T>(value: (T | Thenable<T>)): Task<T>;\n\tpublic static resolve<T>(value?: any): Task<T> {\n\t\treturn new this<T>((resolve, reject) => resolve(value));\n\t}\n\n\tstatic all<T>(iterable: DictionaryOfPromises<T>): Task<{ [key: string]: T }>;\n\tstatic all<T>(iterable: (T | Thenable<T>)[]): Task<T[]>;\n\tstatic all<T>(iterable: T | Thenable<T>): Task<T[]>;\n\tstatic all<T>(iterable: ListOfPromises<T>): Task<T[]>;\n\tstatic all<T>(iterable: DictionaryOfPromises<T> | ListOfPromises<T>): Task<any> {\n\t\treturn <Task<T>> super.all(iterable);\n\t}\n\n\t/**\n\t * A cancelation handler that will be called if this task is canceled.\n\t */\n\tprivate canceler: () => void;\n\n\t/**\n\t * Children of this Task (i.e., Tasks that were created from this Task with `then` or `catch`).\n\t */\n\tprivate readonly children: Task<any>[];\n\n\t/**\n\t * The finally callback for this Task (if it was created by a call to `finally`).\n\t */\n\tprivate _finally: () => void;\n\n\t/**\n\t * The state of the task\n\t */\n\tprotected _state: State;\n\n\tget state() {\n\t\treturn this._state;\n\t}\n\n\t/**\n\t * @constructor\n\t *\n\t * Create a new task. Executor is run immediately. The canceler will be called when the task is canceled.\n\t *\n\t * @param executor Method that initiates some task\n\t * @param canceler Method to call when the task is canceled\n\t *\n\t */\n\tconstructor(executor: Executor<T>, canceler?: () => void) {\n\t\t// we have to initialize these to avoid a compiler error of using them before they are initialized\n\t\tlet superResolve: (value?: T | Thenable<T> | undefined) => void = () => {};\n\t\tlet superReject: (reason?: any) => void = () => {};\n\n\t\tsuper((resolve, reject) => {\n\t\t\tsuperResolve = resolve;\n\t\t\tsuperReject = reject;\n\t\t});\n\n\t\tthis._state = State.Pending;\n\n\t\tthis.children = [];\n\t\tthis.canceler = () => {\n\t\t\tif (canceler) {\n\t\t\t\tcanceler();\n\t\t\t}\n\t\t\tthis._cancel();\n\t\t};\n\n\t\t// Don't let the Task resolve if it's been canceled\n\t\ttry {\n\t\t\texecutor(\n\t\t\t\t(value) => {\n\t\t\t\t\tif (this._state === State.Canceled) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis._state = State.Fulfilled;\n\t\t\t\t\tsuperResolve(value);\n\t\t\t\t},\n\t\t\t\t(reason) => {\n\t\t\t\t\tif (this._state === State.Canceled) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis._state = State.Rejected;\n\t\t\t\t\tsuperReject(reason);\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t\tcatch (reason) {\n\t\t\tthis._state = State.Rejected;\n\t\t\tsuperReject(reason);\n\t\t}\n\t}\n\n\t/**\n\t * Propagates cancellation down through a Task tree. The Task's state is immediately set to canceled. If a Thenable\n\t * finally task was passed in, it is resolved before calling this Task's finally callback; otherwise, this Task's\n\t * finally callback is immediately executed. `_cancel` is called for each child Task, passing in the value returned\n\t * by this Task's finally callback or a Promise chain that will eventually resolve to that value.\n\t */\n\tprivate _cancel(finallyTask?: void | Thenable<any>): void {\n\t\tthis._state = State.Canceled;\n\n\t\tconst runFinally = () => {\n\t\t\ttry {\n\t\t\t\treturn this._finally();\n\t\t\t}\n\t\t\tcatch (error) {\n\t\t\t\t// Any errors in a `finally` callback are completely ignored during cancelation\n\t\t\t}\n\t\t};\n\n\t\tif (this._finally) {\n\t\t\tif (isThenable(finallyTask)) {\n\t\t\t\tfinallyTask = (<Thenable<any>> finallyTask).then(runFinally, runFinally);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfinallyTask = runFinally();\n\t\t\t}\n\t\t}\n\n\t\tthis.children.forEach(function (child) {\n\t\t\tchild._cancel(finallyTask);\n\t\t});\n\t}\n\n\t/**\n\t * Immediately cancels this task if it has not already resolved. This Task and any descendants are synchronously set\n\t * to the Canceled state and any `finally` added downstream from the canceled Task are invoked.\n\t */\n\tcancel(): void {\n\t\tif (this._state === State.Pending) {\n\t\t\tthis.canceler();\n\t\t}\n\t}\n\n\tcatch(onRejected: (reason: Error) => T | Thenable<T> | void): Task<T>;\n\tcatch<U>(onRejected: (reason: Error) => U | Thenable<U>): Task<U> {\n\t\treturn this.then(undefined, onRejected);\n\t}\n\n\t/**\n\t * Allows for cleanup actions to be performed after resolution of a Promise.\n\t */\n\tfinally(callback: () => void): Task<T> {\n\t\t// if this task is already canceled, call the task\n\t\tif (this._state === State.Canceled) {\n\t\t\tcallback();\n\t\t\treturn this;\n\t\t}\n\n\t\tconst task = this.then<any>(\n\t\t\tvalue => Task.resolve(callback()).then(() => value),\n\t\t\treason => Task.resolve(callback()).then(() => {\n\t\t\t\tthrow reason;\n\t\t\t})\n\t\t);\n\n\t\t// Keep a reference to the callback; it will be called if the Task is canceled\n\t\ttask._finally = callback;\n\t\treturn task;\n\t}\n\n\t/**\n\t * Adds a callback to be invoked when the Task resolves or is rejected.\n\t *\n\t * @param {Function} onFulfilled   A function to call to handle the resolution. The paramter to the function will be the resolved value, if any.\n\t * @param {Function} onRejected    A function to call to handle the error. The parameter to the function will be the caught error.\n\t *\n\t * @returns {ExtensiblePromise}\n\t */\n\tthen<U, V>(onFulfilled: ((value: T) => (U | Thenable<U> | undefined)) | undefined, onRejected: (reason: Error) => (V | Thenable<V>)): Task<U | V>;\n\tthen<U>(onFulfilled?: ((value: T) => (U | Thenable<U> | undefined)) | undefined, onRejected?: (reason: Error) => void): Task<U>;\n\tthen<U>(onFulfilled?: ((value: T) => (U | Thenable<U> | undefined)) | undefined, onRejected?: (reason: Error) => (U | Thenable<U>)): Task<U>;\n\tthen<U>(onFulfilled?: (value?: T) => U | Thenable<U>, onRejected?: (error: Error) => U | Thenable<U>): Task<U> {\n\t\t// FIXME\n\t\t// tslint:disable-next-line:no-var-keyword\n\t\tvar task = <Task<U>> super.then<U>(\n\t\t\t// Don't call the onFulfilled or onRejected handlers if this Task is canceled\n\t\t\tfunction (value) {\n\t\t\t\tif (task._state === State.Canceled) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (onFulfilled) {\n\t\t\t\t\treturn onFulfilled(value);\n\t\t\t\t}\n\t\t\t\treturn <any> value;\n\t\t\t},\n\t\t\tfunction (error) {\n\t\t\t\tif (task._state === State.Canceled) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (onRejected) {\n\t\t\t\t\treturn onRejected(error);\n\t\t\t\t}\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t);\n\n\t\ttask.canceler = () => {\n\t\t\t// If task's parent (this) hasn't been resolved, cancel it; downward propagation will start at the first\n\t\t\t// unresolved parent\n\t\t\tif (this._state === State.Pending) {\n\t\t\t\tthis.cancel();\n\t\t\t}\n\t\t\t// If task's parent has been resolved, propagate cancelation to the task's descendants\n\t\t\telse {\n\t\t\t\ttask._cancel();\n\t\t\t}\n\t\t};\n\n\t\t// Keep track of child Tasks for propogating cancelation back down the chain\n\t\tthis.children.push(task);\n\n\t\treturn task;\n\t}\n}\n"]}