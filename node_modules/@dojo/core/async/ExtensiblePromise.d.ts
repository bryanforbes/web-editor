import { Iterable } from '@dojo/shim/iterator';
import Promise, { Executor } from '@dojo/shim/Promise';
import { Thenable } from '@dojo/shim/interfaces';
import '@dojo/shim/Symbol';
export declare type DictionaryOfPromises<T> = {
    [_: string]: T | Promise<T> | Thenable<T>;
};
export declare type ListOfPromises<T> = Iterable<(T | Thenable<T>)>;
/**
 * An extensible base to allow Promises to be extended in ES5. This class basically wraps a native Promise object,
 * giving an API like a native promise.
 */
export default class ExtensiblePromise<T> {
    /**
     * Return a rejected promise wrapped in an ExtensiblePromise
     *
     * @param {Error?} reason    The reason for the rejection
     * @returns {ExtensiblePromise}
     */
    static reject<T>(reason?: Error): any;
    /**
     * Return a resolved promise wrapped in an ExtensiblePromise
     *
     * @param value The value to resolve the promise with
     *
     * @returns {ExtensiblePromise}
     */
    static resolve<F extends ExtensiblePromise<void>>(): F;
    static resolve<T, F extends ExtensiblePromise<T>>(value: (T | Thenable<T>)): F;
    /**
     * Return a ExtensiblePromise that resolves when all of the passed in objects have resolved. When used with a key/value
     * pair, the returned promise's argument is a key/value pair of the original keys with their resolved values.
     *
     * @example
     * ExtensiblePromise.all({ one: 1, two: 2 }).then(results => console.log(results));
     * // { one: 1, two: 2 }
     *
     * @param iterable    An iterable of values to resolve, or a key/value pair of values to resolve. These can be Promises, ExtensiblePromises, or other objects
     * @returns {ExtensiblePromise}
     */
    static all<F extends ExtensiblePromise<{
        [key: string]: T;
    }>, T>(iterable: DictionaryOfPromises<T>): F;
    static all<F extends ExtensiblePromise<T[]>, T>(iterable: (T | Thenable<T>)[]): F;
    static all<F extends ExtensiblePromise<T[]>, T>(iterable: T | Thenable<T>): F;
    static all<F extends ExtensiblePromise<T[]>, T>(iterable: ListOfPromises<T>): F;
    /**
     * Return a ExtensiblePromise that resolves when one of the passed in objects have resolved
     *
     * @param iterable    An iterable of values to resolve. These can be Promises, ExtensiblePromises, or other objects
     * @returns {ExtensiblePromise}
     */
    static race<F extends ExtensiblePromise<T>, T>(iterable: Iterable<(T | Thenable<T>)> | (T | Thenable<T>)[]): F;
    /**
     * @type {Promise}
     * The wrapped promise
     */
    readonly _promise: Promise<T>;
    /**
     * Creates a new extended Promise.
     *
     * @constructor
     *
     * @param executor
     * The executor function is called immediately when the Promise is instantiated. It is responsible for
     * starting the asynchronous operation when it is invoked.
     *
     * The executor must call either the passed `resolve` function when the asynchronous operation has completed
     * successfully, or the `reject` function when the operation fails.
     */
    constructor(executor: Executor<T>);
    /**
     * Adds a callback to be invoked when the wrapped Promise is rejected.
     *
     * @param {Function} onRejected A function to call to handle the error. The parameter to the function will be the caught error.
     *
     * @returns {ExtensiblePromise}
     */
    catch(onRejected: (reason: Error) => T | Thenable<T> | void): ExtensiblePromise<T>;
    /**
     * Adds a callback to be invoked when the wrapped Promise resolves or is rejected.
     *
     * @param {Function} onFulfilled   A function to call to handle the resolution. The paramter to the function will be the resolved value, if any.
     * @param {Function} onRejected    A function to call to handle the error. The parameter to the function will be the caught error.
     *
     * @returns {ExtensiblePromise}
     */
    then<U, V>(onFulfilled: ((value: T) => (U | Thenable<U> | undefined)) | undefined, onRejected: (reason: Error) => (V | Thenable<V>)): ExtensiblePromise<U | V>;
    then<U>(onFulfilled?: ((value: T) => (U | Thenable<U> | undefined)) | undefined, onRejected?: (reason: Error) => void): ExtensiblePromise<U>;
    readonly [Symbol.toStringTag]: 'Promise';
}
