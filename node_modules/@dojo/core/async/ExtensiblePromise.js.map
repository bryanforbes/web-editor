{"version":3,"file":"ExtensiblePromise.js","sourceRoot":"","sources":["ExtensiblePromise.ts"],"names":[],"mappings":"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","sourcesContent":["import { Iterable, forOf, isIterable, isArrayLike } from '@dojo/shim/iterator';\nimport Promise, { Executor } from '@dojo/shim/Promise';\nimport { Thenable } from '@dojo/shim/interfaces';\nimport '@dojo/shim/Symbol';\n\n/**\n * Take a list of values, and if any are ExtensiblePromise objects, insert the wrapped Promise in its place,\n * otherwise use the original object. We use this to help use the native Promise methods like `all` and `race`.\n *\n * @param iterable    The list of objects to iterate over\n * @returns {any[]}    The list of objects, as an array, with ExtensiblePromises being replaced by Promises.\n */\nfunction unwrapPromises(iterable: Iterable<any> | any[]): any[] {\n\tconst unwrapped: any[] = [];\n\tforOf(iterable, function (item: any): void {\n\t\tunwrapped.push(item instanceof ExtensiblePromise ? item._promise : item);\n\t});\n\treturn unwrapped;\n}\n\nexport type DictionaryOfPromises<T> = { [_: string]: T | Promise<T> | Thenable<T> };\nexport type ListOfPromises<T> = Iterable<(T | Thenable<T>)>;\n\n/**\n * An extensible base to allow Promises to be extended in ES5. This class basically wraps a native Promise object,\n * giving an API like a native promise.\n */\nexport default class ExtensiblePromise<T> {\n\t/**\n\t * Return a rejected promise wrapped in an ExtensiblePromise\n\t *\n\t * @param {Error?} reason    The reason for the rejection\n\t * @returns {ExtensiblePromise}\n\t */\n\tstatic reject<T>(reason?: Error): any {\n\t\treturn new this<T>((resolve, reject) => reject(reason));\n\t}\n\n\t/**\n\t * Return a resolved promise wrapped in an ExtensiblePromise\n\t *\n\t * @param value The value to resolve the promise with\n\t *\n\t * @returns {ExtensiblePromise}\n\t */\n\tstatic resolve<F extends ExtensiblePromise<void>>(): F;\n\tstatic resolve<T, F extends ExtensiblePromise<T>>(value: (T | Thenable<T>)): F;\n\tstatic resolve<T, F extends ExtensiblePromise<T>>(value?: any): F {\n\t\treturn <F> new this<T>((resolve, reject) => resolve(value));\n\t}\n\n\t/**\n\t * Return a ExtensiblePromise that resolves when all of the passed in objects have resolved. When used with a key/value\n\t * pair, the returned promise's argument is a key/value pair of the original keys with their resolved values.\n\t *\n\t * @example\n\t * ExtensiblePromise.all({ one: 1, two: 2 }).then(results => console.log(results));\n\t * // { one: 1, two: 2 }\n\t *\n\t * @param iterable    An iterable of values to resolve, or a key/value pair of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n\t * @returns {ExtensiblePromise}\n\t */\n\tstatic all<F extends ExtensiblePromise<{ [key: string]: T }>, T>(iterable: DictionaryOfPromises<T>): F;\n\tstatic all<F extends ExtensiblePromise<T[]>, T>(iterable: (T | Thenable<T>)[]): F;\n\tstatic all<F extends ExtensiblePromise<T[]>, T>(iterable: T | Thenable<T>): F;\n\tstatic all<F extends ExtensiblePromise<T[]>, T>(iterable: ListOfPromises<T>): F;\n\tstatic all<F extends ExtensiblePromise<any>, T>(iterable: DictionaryOfPromises<T> | ListOfPromises<T>): F {\n\t\tif (!isArrayLike(iterable) && !isIterable(iterable)) {\n\t\t\tconst promiseKeys = Object.keys(iterable);\n\n\t\t\treturn <F> new this((resolve, reject) => {\n\t\t\t\tPromise.all(promiseKeys.map(key => (<DictionaryOfPromises<T>> iterable)[ key ])).then((promiseResults: T[]) => {\n\t\t\t\t\tconst returnValue: {[_: string]: T} = {};\n\n\t\t\t\t\tpromiseResults.forEach((value: T, index: number) => {\n\t\t\t\t\t\treturnValue[ promiseKeys[ index ] ] = value;\n\t\t\t\t\t});\n\n\t\t\t\t\tresolve(returnValue);\n\t\t\t\t}, reject);\n\t\t\t});\n\t\t}\n\n\t\treturn <F> new this((resolve, reject) => {\n\t\t\tPromise.all(unwrapPromises(<Iterable<T>> iterable)).then(resolve, reject);\n\t\t});\n\t}\n\n\t/**\n\t * Return a ExtensiblePromise that resolves when one of the passed in objects have resolved\n\t *\n\t * @param iterable    An iterable of values to resolve. These can be Promises, ExtensiblePromises, or other objects\n\t * @returns {ExtensiblePromise}\n\t */\n\tstatic race<F extends ExtensiblePromise<T>, T>(iterable: Iterable<(T | Thenable<T>)> | (T | Thenable<T>)[]): F {\n\t\treturn <F> new this((resolve, reject) => {\n\t\t\tPromise.race(unwrapPromises(iterable)).then(resolve, reject);\n\t\t});\n\t}\n\n\t/**\n\t * @type {Promise}\n\t * The wrapped promise\n\t */\n\treadonly _promise: Promise<T>;\n\n\t/**\n\t * Creates a new extended Promise.\n\t *\n\t * @constructor\n\t *\n\t * @param executor\n\t * The executor function is called immediately when the Promise is instantiated. It is responsible for\n\t * starting the asynchronous operation when it is invoked.\n\t *\n\t * The executor must call either the passed `resolve` function when the asynchronous operation has completed\n\t * successfully, or the `reject` function when the operation fails.\n\t */\n\tconstructor(executor: Executor<T>) {\n\t\tthis._promise = new Promise<T>(executor);\n\t}\n\n\t/**\n\t * Adds a callback to be invoked when the wrapped Promise is rejected.\n\t *\n\t * @param {Function} onRejected A function to call to handle the error. The parameter to the function will be the caught error.\n\t *\n\t * @returns {ExtensiblePromise}\n\t */\n\tcatch(onRejected: (reason: Error) => T | Thenable<T> | void): ExtensiblePromise<T>;\n\tcatch<U>(onRejected: (reason: Error) => U | Thenable<U>): ExtensiblePromise<U> {\n\t\treturn this.then<U>(undefined, onRejected);\n\t}\n\n\t/**\n\t * Adds a callback to be invoked when the wrapped Promise resolves or is rejected.\n\t *\n\t * @param {Function} onFulfilled   A function to call to handle the resolution. The paramter to the function will be the resolved value, if any.\n\t * @param {Function} onRejected    A function to call to handle the error. The parameter to the function will be the caught error.\n\t *\n\t * @returns {ExtensiblePromise}\n\t */\n\tthen<U, V>(onFulfilled: ((value: T) => (U | Thenable<U> | undefined)) | undefined, onRejected: (reason: Error) => (V | Thenable<V>)): ExtensiblePromise<U | V>;\n\tthen<U>(onFulfilled?: ((value: T) => (U | Thenable<U> | undefined)) | undefined, onRejected?: (reason: Error) => void): ExtensiblePromise<U>;\n\tthen<U>(onFulfilled?: ((value: T) => (U | Thenable<U> | undefined)) | undefined, onRejected?: (reason: Error) => (U | Thenable<U>)): ExtensiblePromise<U> {\n\t\tconst e: Executor<U> = (resolve, reject) => {\n\t\t\tfunction handler(rejected: boolean, valueOrError: T | U | Error) {\n\t\t\t\tconst callback: ((value: T | U | Error) => (U | Thenable<U> | void)) | undefined = rejected ? onRejected : onFulfilled;\n\n\t\t\t\tif (typeof callback === 'function') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tresolve(<U> callback(<T> valueOrError));\n\t\t\t\t\t}\n\t\t\t\t\tcatch (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (rejected) {\n\t\t\t\t\treject(valueOrError);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresolve(<U> valueOrError);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._promise.then(handler.bind(null, false), handler.bind(null, true));\n\t\t};\n\n\t\treturn new (<{ new(executor: Executor<U>): any }> this.constructor)(e);\n\t}\n\n\treadonly [Symbol.toStringTag]: 'Promise';\n}\n"]}